{:rename-macros {}, :renames {}, :externs {console {log {apply {}}, error {apply {}}}, ReferenceError {}, Error {prototype {name {}, description {}, number {}, fileName {}, lineNumber {}, columnNumber {}, stack {}}}, Object {}, isFinite {}, Symbol {iterator {}}, Infinity {}, String {fromCharCode {}}, eval {}, Array {isArray {}}, parseInt {}, TypeError {}, isNaN {}, goog {isArrayLike {}, nodeGlobalRequire {}}, parseFloat {}, global {}, performance {now {}}, process {hrtime {}}, Number {POSITIVE_INFINITY {}, NEGATIVE_INFINITY {}, MAX_VALUE {}}, RegExp {prototype {exec {}, lastIndex {}}}, Date {prototype {getTime {}, valueOf {}}}, COMPILED {}}, :use-macros {}, :excludes #{}, :name cljs.core, :imports {StringBuffer goog.string.StringBuffer}, :requires {goog.math.Long goog.math.Long, goog.math.Integer goog.math.Integer, gstring goog.string, goog.string goog.string, gobject goog.object, goog.object goog.object, garray goog.array, goog.array goog.array, StringBuffer goog.string.StringBuffer}, :cljs.spec/speced-vars [], :uses nil, :defs {->PersistentHashSet {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8755, :column 10, :end-line 8755, :end-column 27, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/ILookup}, :factory :positional, :arglists (quote ([meta hash-map __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/->PersistentHashSet, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([meta hash-map __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 8755, :end-line 8755, :max-fixed-arity 3, :fn-var true, :arglists (quote ([meta hash-map __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/ILookup}}, js->clj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10243, :column 7, :end-line 10243, :end-column 14, :arglists (quote ([x] [x & opts])), :doc "Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option ':keywordize-keys true' will convert object fields from\n  strings to keywords.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([x]), :arglists ([x] [x & opts]), :arglists-meta (nil nil)}}, :name cljs.core/js->clj, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([x]), :arglists ([x] [x & opts]), :arglists-meta (nil nil)}, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10243, :end-line 10243, :max-fixed-arity 1, :fn-var true, :arglists ([x] [x & opts]), :doc "Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option ':keywordize-keys true' will convert object fields from\n  strings to keywords."}, sort-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2415, :column 7, :end-line 2415, :end-column 14, :arglists (quote ([keyfn coll] [keyfn comp coll])), :doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([keyfn coll] [keyfn comp coll]), :arglists ([keyfn coll] [keyfn comp coll]), :arglists-meta (nil nil)}}, :name cljs.core/sort-by, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([keyfn coll] [keyfn comp coll]), :arglists ([keyfn coll] [keyfn comp coll]), :arglists-meta (nil nil)}, :method-params ([keyfn coll] [keyfn comp coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2415, :end-line 2415, :max-fixed-arity 3, :fn-var true, :arglists ([keyfn coll] [keyfn comp coll]), :doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare."}, ITransientAssociative {:meta {:file "cljs/core.cljs", :line 781, :column 14, :end-line 781, :end-column 35, :doc "Protocol for adding associativity to transient collections.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-assoc! [[tcoll key val]]}}}, :protocol-symbol true, :name cljs.core/ITransientAssociative, :file "cljs/core.cljs", :end-column 35, :column 1, :line 781, :protocol-info {:methods {-assoc! [[tcoll key val]]}}, :info nil, :end-line 781, :tag any, :impls #{cljs.core/TransientVector cljs.core/TransientHashMap cljs.core/TransientArrayMap}, :doc "Protocol for adding associativity to transient collections.", :jsdoc ("@interface")}, chunk-first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3583, :column 7, :end-line 3583, :end-column 18, :arglists (quote ([s]))}, :name cljs.core/chunk-first, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3583, :end-line 3583, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, print-meta? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9609, :column 16, :end-line 9609, :end-column 27, :tag boolean, :arglists (quote ([opts obj]))}, :name cljs.core/print-meta?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([opts obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9609, :ret-tag boolean, :end-line 9609, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([opts obj]))}, m3-hash-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 917, :column 15, :end-line 917, :end-column 26, :tag number, :arglists (quote ([in]))}, :name cljs.core/m3-hash-int, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([in]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 917, :ret-tag number, :end-line 917, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([in]))}, pr-str* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 865, :column 7, :end-line 865, :end-column 14, :arglists (quote ([obj])), :doc "Support so that collections can implement toString without\n   loading all the printing machinery."}, :name cljs.core/pr-str*, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 865, :end-line 865, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj])), :doc "Support so that collections can implement toString without\n   loading all the printing machinery."}, eduction {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10186, :column 7, :end-line 10186, :end-column 15, :arglists (quote ([xform* coll])), :doc "Returns a reducible/iterable application of the transducers\n  to the items in coll. Transducers are applied in order as if\n  combined with comp. Note that these applications will be\n  performed every time reduce/iterator is called.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(xforms)], :arglists ([& xforms]), :arglists-meta (nil)}}, :name cljs.core/eduction, :variadic true, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(xforms)], :arglists ([& xforms]), :arglists-meta (nil)}, :method-params [(xforms)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 10186, :end-line 10186, :max-fixed-arity 0, :fn-var true, :arglists ([& xforms]), :doc "Returns a reducible/iterable application of the transducers\n  to the items in coll. Transducers are applied in order as if\n  combined with comp. Note that these applications will be\n  performed every time reduce/iterator is called."}, tree-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4881, :column 7, :end-line 4881, :end-column 15, :arglists (quote ([branch? children root])), :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n  branch? must be a fn of one arg that returns true if passed a node\n  that can have children (but may not).  children must be a fn of one\n  arg that returns a sequence of the children. Will only be called on\n  nodes for which branch? returns true. Root is the root node of the\n  tree."}, :name cljs.core/tree-seq, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([branch? children root]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4881, :end-line 4881, :max-fixed-arity 3, :fn-var true, :arglists (quote ([branch? children root])), :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n  branch? must be a fn of one arg that returns true if passed a node\n  that can have children (but may not).  children must be a fn of one\n  arg that returns a sequence of the children. Will only be called on\n  nodes for which branch? returns true. Root is the root node of the\n  tree."}, unchecked-remainder-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2742, :column 7, :end-line 2742, :end-column 30, :arglists (quote ([x n]))}, :name cljs.core/unchecked-remainder-int, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2742, :end-line 2742, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n]))}, uuid {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10770, :column 7, :end-line 10770, :end-column 11, :arglists (quote ([s]))}, :name cljs.core/uuid, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10770, :end-line 10770, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1190, :column 12, :end-line 1190, :end-column 15, :tag seq, :arglists (quote ([coll])), :doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings."}, :name cljs.core/seq, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1190, :ret-tag seq, :end-line 1190, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings."}, Volatile {:num-fields 1, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :name cljs.core/Volatile, :file "cljs/core.cljs", :end-column 18, :type true, :column 10, :line 4475, :record false, :end-line 4475, :skip-protocol-flag #{cljs.core/IDeref}}, reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2472, :column 7, :end-line 2472, :end-column 13, :arglists (quote ([f coll] [f val coll])), :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f val coll]), :arglists ([f coll] [f val coll]), :arglists-meta (nil nil)}}, :name cljs.core/reduce, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f val coll]), :arglists ([f coll] [f val coll]), :arglists-meta (nil nil)}, :method-params ([f coll] [f val coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2472, :end-line 2472, :max-fixed-arity 3, :fn-var true, :arglists ([f coll] [f val coll]), :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called."}, IUUID {:meta {:file "cljs/core.cljs", :line 10742, :column 14, :end-line 10742, :end-column 19, :doc "A marker protocol for UUIDs", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/IUUID, :file "cljs/core.cljs", :end-column 19, :column 1, :line 10742, :protocol-info {:methods {}}, :info nil, :end-line 10742, :tag any, :impls #{cljs.core/UUID}, :doc "A marker protocol for UUIDs", :jsdoc ("@interface")}, INIT {:name cljs.core/INIT, :file "cljs/core.cljs", :line 3978, :column 1, :end-line 3978, :end-column 10, :meta {:file "cljs/core.cljs", :line 3978, :column 6, :end-line 3978, :end-column 10}, :tag object}, find-ns {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11102, :column 7, :end-line 11102, :end-column 14, :arglists (quote ([ns])), :doc "Returns the namespace named by the symbol or nil if it doesn't exist.\n  Bootstrap only."}, :name cljs.core/find-ns, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([ns]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 11102, :end-line 11102, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ns])), :doc "Returns the namespace named by the symbol or nil if it doesn't exist.\n  Bootstrap only."}, contains? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2304, :column 16, :end-line 2304, :end-column 25, :tag boolean, :arglists (quote ([coll v])), :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'."}, :name cljs.core/contains?, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([coll v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2304, :ret-tag boolean, :end-line 2304, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([coll v])), :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'."}, every? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4165, :column 16, :end-line 4165, :end-column 22, :tag boolean, :arglists (quote ([pred coll])), :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false."}, :name cljs.core/every?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4165, :ret-tag boolean, :end-line 4165, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false."}, ->ES6IteratorSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1281, :column 10, :end-line 1281, :end-column 24, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}, :factory :positional, :arglists (quote ([value iter _rest]))}, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :name cljs.core/->ES6IteratorSeq, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([value iter _rest]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1281, :end-line 1281, :max-fixed-arity 3, :fn-var true, :arglists (quote ([value iter _rest])), :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}}, Var {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/IMeta cljs.core/Fn cljs.core/IDeref cljs.core/IWithMeta}, :name cljs.core/Var, :file "cljs/core.cljs", :end-column 13, :type true, :column 10, :line 1098, :record false, :end-line 1098, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/IMeta cljs.core/IDeref cljs.core/IWithMeta}}, keep-indexed {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4497, :column 7, :end-line 4497, :end-column 19, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name cljs.core/keep-indexed, :variadic false, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4497, :end-line 4497, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided."}, ->PersistentQueueSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5872, :column 10, :end-line 5872, :end-column 28, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([meta front rear __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->PersistentQueueSeq, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([meta front rear __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5872, :end-line 5872, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta front rear __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}}, subs {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2938, :column 7, :end-line 2938, :end-column 11, :arglists (quote ([s start] [s start end])), :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([s start] [s start end]), :arglists ([s start] [s start end]), :arglists-meta (nil nil)}}, :name cljs.core/subs, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([s start] [s start end]), :arglists ([s start] [s start end]), :arglists-meta (nil nil)}, :method-params ([s start] [s start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2938, :end-line 2938, :max-fixed-arity 3, :fn-var true, :arglists ([s start] [s start end]), :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive."}, IFind {:meta {:file "cljs/core.cljs", :line 622, :column 14, :end-line 622, :end-column 19, :doc "Protocol for implementing entry finding in collections.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-find [[coll k]]}}}, :protocol-symbol true, :name cljs.core/IFind, :file "cljs/core.cljs", :end-column 19, :column 1, :line 622, :protocol-info {:methods {-find [[coll k]]}}, :info nil, :end-line 622, :tag any, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/BlackNode cljs.core/MapEntry cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap cljs.core/RedNode}, :doc "Protocol for implementing entry finding in collections.", :jsdoc ("@interface")}, set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9011, :column 7, :end-line 9011, :end-column 10, :arglists (quote ([coll])), :doc "Returns a set of the distinct elements of coll."}, :name cljs.core/set, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9011, :end-line 9011, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a set of the distinct elements of coll."}, MODULE_URIS {:name cljs.core/MODULE_URIS, :file "cljs/core.cljs", :line 38, :column 1, :end-line 38, :end-column 17, :meta {:file "cljs/core.cljs", :line 38, :column 6, :end-line 38, :end-column 17}, :tag clj-nil}, compare-indexed {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2369, :column 17, :end-line 2369, :end-column 32, :private true, :arglists (quote ([xs ys] [xs ys len n])), :doc "Compare indexed collection.", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([xs ys] [xs ys len n]), :arglists ([xs ys] [xs ys len n]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/compare-indexed, :variadic false, :file "cljs/core.cljs", :end-column 32, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([xs ys] [xs ys len n]), :arglists ([xs ys] [xs ys len n]), :arglists-meta (nil nil)}, :method-params ([xs ys] [xs ys len n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2369, :end-line 2369, :max-fixed-arity 4, :fn-var true, :arglists ([xs ys] [xs ys len n]), :doc "Compare indexed collection."}, take-last {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4715, :column 7, :end-line 4715, :end-column 16, :arglists (quote ([n coll])), :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec."}, :name cljs.core/take-last, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4715, :end-line 4715, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec."}, IndexedSeq {:meta {:file "cljs/core.cljs", :line 1173, :column 29, :end-line 1173, :end-column 39, :declared true}, :num-fields 3, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/IndexedSeq, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 1556, :record false, :declared true, :end-line 1556, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, bit-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2853, :column 7, :end-line 2853, :end-column 14, :arglists (quote ([x n])), :doc "Set bit at index n"}, :name cljs.core/bit-set, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2853, :end-line 2853, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Set bit at index n"}, string-hash-cache-count {:name cljs.core/string-hash-cache-count, :file "cljs/core.cljs", :line 944, :column 1, :end-line 944, :end-column 29, :meta {:file "cljs/core.cljs", :line 944, :column 6, :end-line 944, :end-column 29}, :tag number}, qualified-keyword? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3343, :column 16, :end-line 3343, :end-column 34, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a keyword with a namespace"}, :name cljs.core/qualified-keyword?, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3343, :ret-tag boolean, :end-line 3343, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a keyword with a namespace"}, ->Eduction {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10156, :column 10, :end-line 10156, :end-column 18, :protocols #{cljs.core/Object cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :factory :positional, :arglists (quote ([xform coll]))}, :protocols #{cljs.core/Object cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/->Eduction, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([xform coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 10156, :end-line 10156, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform coll])), :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}}, tree-map-add {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8240, :column 8, :end-line 8240, :end-column 20, :private true, :arglists (quote ([comp tree k v found]))}, :private true, :name cljs.core/tree-map-add, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([comp tree k v found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8240, :end-line 8240, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp tree k v found]))}, ->ES6SetEntriesIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6215, :column 10, :end-line 6215, :end-column 31, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([s]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ES6SetEntriesIterator, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6215, :end-line 6215, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil}, -with-meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 674, :column 9, :end-line 674, :end-column 19, :tag clj, :protocol cljs.core/IWithMeta, :doc "Returns a new object with value of o and metadata meta added to it.", :arglists (quote ([o meta]))}, :protocol cljs.core/IWithMeta, :name cljs.core/-with-meta, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([o meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 672, :ret-tag clj, :end-line 674, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([o meta])), :doc "Returns a new object with value of o and metadata meta added to it."}, reset-cache {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10450, :column 8, :end-line 10450, :end-column 19, :private true, :arglists (quote ([method-cache method-table cached-hierarchy hierarchy]))}, :private true, :name cljs.core/reset-cache, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([method-cache method-table cached-hierarchy hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10450, :end-line 10450, :max-fixed-arity 4, :fn-var true, :arglists (quote ([method-cache method-table cached-hierarchy hierarchy]))}, ->PersistentArrayMapIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6467, :column 10, :end-line 6467, :end-column 36, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([arr i cnt]))}, :protocols #{cljs.core/Object}, :name cljs.core/->PersistentArrayMapIterator, :variadic false, :file "cljs/core.cljs", :end-column 36, :method-params ([arr i cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6467, :end-line 6467, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i cnt])), :skip-protocol-flag nil}, PersistentArrayMapIterator {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/PersistentArrayMapIterator, :file "cljs/core.cljs", :end-column 36, :type true, :column 10, :line 6467, :record false, :end-line 6467, :skip-protocol-flag nil}, butlast {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9089, :column 7, :end-line 9089, :end-column 14, :arglists (quote ([s])), :doc "Return a seq of all but the last item in coll, in linear time"}, :name cljs.core/butlast, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9089, :end-line 9089, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Return a seq of all but the last item in coll, in linear time"}, tail-off {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5054, :column 8, :end-line 5054, :end-column 16, :private true, :arglists (quote ([pv]))}, :private true, :name cljs.core/tail-off, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([pv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5054, :end-line 5054, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pv]))}, unchecked-subtract-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2752, :column 15, :end-line 2752, :end-column 37, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/unchecked-subtract-int, :variadic true, :file "cljs/core.cljs", :end-column 37, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2752, :ret-tag number, :end-line 2752, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result."}, -iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 855, :column 4, :end-line 855, :end-column 13, :protocol cljs.core/IIterable, :doc "Returns an iterator for coll.", :arglists (quote ([coll]))}, :protocol cljs.core/IIterable, :name cljs.core/-iterator, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 853, :end-line 855, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an iterator for coll."}, *print-namespace-maps* {:meta {:file "cljs/core.cljs", :line 128, :column 3, :end-line 128, :end-column 25, :dynamic true, :doc "*print-namespace-maps* controls whether the printer will print\n  namespace map literal syntax.\n\n  Defaults to false, but the REPL binds it to true."}, :name cljs.core/*print-namespace-maps*, :file "cljs/core.cljs", :end-column 25, :column 1, :dynamic true, :line 122, :end-line 128, :tag boolean, :doc "*print-namespace-maps* controls whether the printer will print\n  namespace map literal syntax.\n\n  Defaults to false, but the REPL binds it to true."}, take-nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9346, :column 7, :end-line 9346, :end-column 15, :arglists (quote ([n] [n coll])), :doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/take-nth, :variadic false, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9346, :end-line 9346, :max-fixed-arity 2, :fn-var true, :arglists ([n] [n coll]), :doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided."}, first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1213, :column 7, :end-line 1213, :end-column 12, :arglists (quote ([coll])), :doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil."}, :name cljs.core/first, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1213, :end-line 1213, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil."}, native-satisfies? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 268, :column 16, :end-line 268, :end-column 33, :tag boolean, :arglists (quote ([p x])), :doc "Internal - do not use!"}, :name cljs.core/native-satisfies?, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([p x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 268, :ret-tag boolean, :end-line 268, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([p x])), :doc "Internal - do not use!"}, seq? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2199, :column 16, :end-line 2199, :end-column 20, :tag boolean, :arglists (quote ([s])), :doc "Return true if s satisfies ISeq"}, :name cljs.core/seq?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2199, :ret-tag boolean, :end-line 2199, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([s])), :doc "Return true if s satisfies ISeq"}, -global-hierarchy {:meta {:file "cljs/core.cljs", :line 10340, :column 3, :end-line 10340, :end-column 20, :private true, :jsdoc ["@type {*}"]}, :private true, :name cljs.core/-global-hierarchy, :file "cljs/core.cljs", :end-column 20, :column 1, :line 10337, :end-line 10340, :tag clj-nil, :jsdoc ["@type {*}"]}, UUID {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/IComparable cljs.core/IUUID}, :name cljs.core/UUID, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 10744, :record false, :end-line 10744, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/IComparable}}, -sorted-seq-from {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 726, :column 9, :end-line 726, :end-column 25, :tag clj, :protocol cljs.core/ISorted, :doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)", :arglists (quote ([coll k ascending?]))}, :protocol cljs.core/ISorted, :name cljs.core/-sorted-seq-from, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([coll k ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 721, :ret-tag clj, :end-line 726, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll k ascending?])), :doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)"}, println-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9786, :column 7, :end-line 9786, :end-column 18, :arglists (quote ([& objs])), :doc "println to a string, returning it", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/println-str, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9786, :end-line 9786, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "println to a string, returning it"}, inst-ms {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1372, :column 7, :end-line 1372, :end-column 14, :arglists (quote ([inst])), :doc "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT"}, :name cljs.core/inst-ms, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([inst]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1372, :end-line 1372, :max-fixed-arity 1, :fn-var true, :arglists (quote ([inst])), :doc "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT"}, linear-traversal-nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1809, :column 8, :end-line 1809, :end-column 28, :private true, :arglists (quote ([coll n] [coll n not-found])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/linear-traversal-nth, :variadic false, :file "cljs/core.cljs", :end-column 28, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1809, :end-line 1809, :max-fixed-arity 3, :fn-var true, :arglists ([coll n] [coll n not-found])}, iterate {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4777, :column 7, :end-line 4777, :end-column 14, :arglists (quote ([f x])), :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :added "1.0"}, :added "1.0", :name cljs.core/iterate, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([f x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4777, :end-line 4777, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f x])), :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects"}, checked-aget' {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 468, :column 8, :end-line 468, :end-column 21, :private true, :arglists (quote ([array idx] [array idx & idxs])), :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([array idx]), :arglists ([array idx] [array idx & idxs]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/checked-aget', :variadic true, :file "cljs/core.cljs", :end-column 21, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([array idx]), :arglists ([array idx] [array idx & idxs]), :arglists-meta (nil nil)}, :method-params ([array idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 468, :end-line 468, :max-fixed-arity 2, :fn-var true, :arglists ([array idx] [array idx & idxs])}, -empty {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 565, :column 4, :end-line 565, :end-column 10, :protocol cljs.core/IEmptyableCollection, :doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty.", :arglists (quote ([coll]))}, :protocol cljs.core/IEmptyableCollection, :name cljs.core/-empty, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 563, :end-line 565, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty."}, newline {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9741, :column 7, :end-line 9741, :end-column 14, :arglists (quote ([] [opts])), :doc "Prints a newline using *print-fn*", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [opts]), :arglists ([] [opts]), :arglists-meta (nil nil)}}, :name cljs.core/newline, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [opts]), :arglists ([] [opts]), :arglists-meta (nil nil)}, :method-params ([] [opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9741, :end-line 9741, :max-fixed-arity 1, :fn-var true, :arglists ([] [opts]), :doc "Prints a newline using *print-fn*"}, ILookup {:meta {:file "cljs/core.cljs", :line 607, :column 14, :end-line 607, :end-column 21, :doc "Protocol for looking up a value in a data structure.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-lookup [[o k] [o k not-found]]}}}, :protocol-symbol true, :name cljs.core/ILookup, :file "cljs/core.cljs", :end-column 21, :column 1, :line 607, :protocol-info {:methods {-lookup [[o k] [o k not-found]]}}, :info nil, :end-line 607, :tag any, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/BlackNode cljs.core/MapEntry cljs.core/Subvec cljs.core/TransientHashMap cljs.core/TaggedLiteral cljs.core/PersistentVector cljs.core/TransientArrayMap cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/RedNode}, :doc "Protocol for looking up a value in a data structure.", :jsdoc ("@interface")}, -chunked-rest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 819, :column 4, :end-line 819, :end-column 17, :protocol cljs.core/IChunkedSeq, :doc "Return a new collection of coll with the first chunk removed.", :arglists (quote ([coll]))}, :protocol cljs.core/IChunkedSeq, :name cljs.core/-chunked-rest, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 815, :end-line 819, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a new collection of coll with the first chunk removed."}, write-all {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9577, :column 7, :end-line 9577, :end-column 16, :arglists (quote ([writer & ss])), :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(writer ss)], :arglists ([writer & ss]), :arglists-meta (nil)}}, :name cljs.core/write-all, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(writer ss)], :arglists ([writer & ss]), :arglists-meta (nil)}, :method-params [(writer ss)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9577, :end-line 9577, :max-fixed-arity 1, :fn-var true, :arglists ([writer & ss])}, fn? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1976, :column 16, :end-line 1976, :end-column 19, :tag boolean, :arglists (quote ([f])), :doc "Return true if f is a JavaScript function or satisfies the Fn protocol."}, :name cljs.core/fn?, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1976, :ret-tag boolean, :end-line 1976, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :doc "Return true if f is a JavaScript function or satisfies the Fn protocol."}, -prefer-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10509, :column 4, :end-line 10509, :end-column 18, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf dispatch-val dispatch-val-y]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-prefer-method, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([mf dispatch-val dispatch-val-y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10505, :end-line 10509, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf dispatch-val dispatch-val-y])), :doc nil}, -assoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 618, :column 9, :end-line 618, :end-column 15, :tag clj, :protocol cljs.core/IAssociative, :doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it.", :arglists (quote ([coll k v]))}, :protocol cljs.core/IAssociative, :name cljs.core/-assoc, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 613, :ret-tag clj, :end-line 618, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll k v])), :doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it."}, doall {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9487, :column 7, :end-line 9487, :end-column 12, :arglists (quote ([coll] [n coll])), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [n coll]), :arglists ([coll] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/doall, :variadic false, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [n coll]), :arglists ([coll] [n coll]), :arglists-meta (nil nil)}, :method-params ([coll] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9487, :end-line 9487, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [n coll]), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time."}, keyword-identical? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3294, :column 16, :end-line 3294, :end-column 34, :tag boolean, :arglists (quote ([x y])), :doc "Efficient test to determine that two keywords are identical."}, :name cljs.core/keyword-identical?, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3294, :ret-tag boolean, :end-line 3294, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x y])), :doc "Efficient test to determine that two keywords are identical."}, *print-err-fn* {:meta {:file "cljs/core.cljs", :line 74, :column 3, :end-line 74, :end-column 17, :doc "Each runtime environment provides a different way to print error output.\n  Whatever function *print-err-fn* is bound to will be passed any\n  Strings which should be printed.", :dynamic true}, :name cljs.core/*print-err-fn*, :file "cljs/core.cljs", :end-column 17, :column 1, :dynamic true, :line 70, :end-line 74, :tag clj-nil, :doc "Each runtime environment provides a different way to print error output.\n  Whatever function *print-err-fn* is bound to will be passed any\n  Strings which should be printed."}, pv-aset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5048, :column 8, :end-line 5048, :end-column 15, :private true, :arglists (quote ([node idx val]))}, :private true, :name cljs.core/pv-aset, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([node idx val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5048, :end-line 5048, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node idx val]))}, prefers {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10729, :column 7, :end-line 10729, :end-column 14, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of preferred value -> set of other values"}, :name cljs.core/prefers, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10729, :end-line 10729, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of preferred value -> set of other values"}, -js->clj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10241, :column 4, :end-line 10241, :end-column 12, :protocol cljs.core/IEncodeClojure, :doc "Transforms JavaScript values to Clojure", :arglists (quote ([x options]))}, :protocol cljs.core/IEncodeClojure, :name cljs.core/-js->clj, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x options]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10240, :end-line 10241, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x options])), :doc "Transforms JavaScript values to Clojure"}, LazySeq {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/LazySeq, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 3371, :record false, :end-line 3371, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, dedupe {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10129, :column 7, :end-line 10129, :end-column 13, :arglists (quote ([] [coll])), :doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}}, :name cljs.core/dedupe, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}, :method-params ([] [coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10129, :end-line 10129, :max-fixed-arity 1, :fn-var true, :arglists ([] [coll]), :doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided."}, unchecked-editable-array-for {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5708, :column 8, :end-line 5708, :end-column 36, :private true, :arglists (quote ([tv i]))}, :private true, :name cljs.core/unchecked-editable-array-for, :variadic false, :file "cljs/core.cljs", :end-column 36, :method-params ([tv i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5708, :end-line 5708, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tv i]))}, ->ES6Iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1265, :column 10, :end-line 1265, :end-column 21, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([s]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ES6Iterator, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1265, :end-line 1265, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil}, VectorNode {:num-fields 2, :protocols #{}, :name cljs.core/VectorNode, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 5040, :record false, :end-line 5040, :skip-protocol-flag nil}, dissoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1962, :column 7, :end-line 1962, :end-column 13, :arglists (quote ([coll] [coll k] [coll k & ks])), :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [coll k]), :arglists ([coll] [coll k] [coll k & ks]), :arglists-meta (nil nil nil)}}, :name cljs.core/dissoc, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [coll k]), :arglists ([coll] [coll k] [coll k & ks]), :arglists-meta (nil nil nil)}, :method-params ([coll] [coll k]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1962, :end-line 1962, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [coll k] [coll k & ks]), :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s)."}, atom {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4391, :column 7, :end-line 4391, :end-column 11, :arglists (quote ([x] [x & {:keys [meta validator]}])), :doc "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will be come the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an Error.  If either of these error conditions\n  occur, then the value of the atom will not change.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([x]), :arglists ([x] [x & {:keys [meta validator]}]), :arglists-meta (nil nil)}}, :name cljs.core/atom, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([x]), :arglists ([x] [x & {:keys [meta validator]}]), :arglists-meta (nil nil)}, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4391, :end-line 4391, :max-fixed-arity 1, :fn-var true, :arglists ([x] [x & {:keys [meta validator]}]), :doc "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will be come the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an Error.  If either of these error conditions\n  occur, then the value of the atom will not change."}, bit-shift-right {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2867, :column 7, :end-line 2867, :end-column 22, :arglists (quote ([x n])), :doc "Bitwise shift right"}, :name cljs.core/bit-shift-right, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2867, :end-line 2867, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift right"}, MapEntry {:num-fields 3, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/MapEntry, :file "cljs/core.cljs", :end-column 18, :type true, :column 10, :line 6306, :record false, :end-line 6306, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, *clojurescript-version* {:name cljs.core/*clojurescript-version*, :file "cljs/core.cljs", :line 18, :column 1, :end-line 18, :end-column 29, :meta {:file "cljs/core.cljs", :line 18, :column 6, :end-line 18, :end-column 29}, :tag string}, -first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 591, :column 4, :end-line 591, :end-column 10, :protocol cljs.core/ISeq, :doc "Returns the first item in the collection coll. Used by cljs.core/first.", :arglists (quote ([coll]))}, :protocol cljs.core/ISeq, :name cljs.core/-first, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 589, :end-line 591, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the first item in the collection coll. Used by cljs.core/first."}, peek {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2050, :column 7, :end-line 2050, :end-column 11, :arglists (quote ([coll])), :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil."}, :name cljs.core/peek, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2050, :end-line 2050, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil."}, IKVReduce {:meta {:file "cljs/core.cljs", :line 685, :column 14, :end-line 685, :end-column 23, :doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-kv-reduce [[coll f init]]}}}, :protocol-symbol true, :name cljs.core/IKVReduce, :file "cljs/core.cljs", :end-column 23, :column 1, :line 685, :protocol-info {:methods {-kv-reduce [[coll f init]]}}, :info nil, :end-line 685, :tag any, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap}, :doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv.", :jsdoc ("@interface")}, iter-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2449, :column 8, :end-line 2449, :end-column 19, :private true, :arglists (quote ([coll f] [coll f init])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll f] [coll f init]), :arglists ([coll f] [coll f init]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/iter-reduce, :variadic false, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll f] [coll f init]), :arglists ([coll f] [coll f init]), :arglists-meta (nil nil)}, :method-params ([coll f] [coll f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2449, :end-line 2449, :max-fixed-arity 3, :fn-var true, :arglists ([coll f] [coll f init])}, aget {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 484, :column 7, :end-line 484, :end-column 11, :arglists (quote ([array idx] [array idx & idxs])), :doc "Returns the value at the index/indices. Works on JavaScript arrays.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([array idx]), :arglists ([array idx] [array idx & idxs]), :arglists-meta (nil nil)}}, :name cljs.core/aget, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([array idx]), :arglists ([array idx] [array idx & idxs]), :arglists-meta (nil nil)}, :method-params ([array idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 484, :end-line 484, :max-fixed-arity 2, :fn-var true, :arglists ([array idx] [array idx & idxs]), :doc "Returns the value at the index/indices. Works on JavaScript arrays."}, PersistentTreeMapSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/PersistentTreeMapSeq, :file "cljs/core.cljs", :end-column 30, :type true, :column 10, :line 7785, :record false, :end-line 7785, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -write {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 740, :column 4, :end-line 740, :end-column 10, :protocol cljs.core/IWriter, :doc "Writes s with writer and returns the result.", :arglists (quote ([writer s]))}, :protocol cljs.core/IWriter, :name cljs.core/-write, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([writer s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 738, :end-line 740, :max-fixed-arity 2, :fn-var true, :arglists (quote ([writer s])), :doc "Writes s with writer and returns the result."}, iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4002, :column 7, :end-line 4002, :end-column 11, :arglists (quote ([coll]))}, :name cljs.core/iter, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4002, :end-line 4002, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, mk-bound-fn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9193, :column 7, :end-line 9193, :end-column 18, :arglists (quote ([sc test key]))}, :name cljs.core/mk-bound-fn, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([sc test key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9193, :end-line 9193, :max-fixed-arity 3, :fn-var true, :arglists (quote ([sc test key]))}, last {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1749, :column 7, :end-line 1749, :end-column 11, :arglists (quote ([s])), :doc "Return the last item in coll, in linear time"}, :name cljs.core/last, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1749, :end-line 1749, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Return the last item in coll, in linear time"}, -default-dispatch-val {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10513, :column 4, :end-line 10513, :end-column 25, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-default-dispatch-val, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10505, :end-line 10513, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, pr {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9759, :column 7, :end-line 9759, :end-column 9, :arglists (quote ([& objs])), :doc "Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/pr, :variadic true, :file "cljs/core.cljs", :end-column 9, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9759, :end-line 9759, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader"}, tree-map-seq-push {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7778, :column 8, :end-line 7778, :end-column 25, :private true, :arglists (quote ([node stack ascending?]))}, :private true, :name cljs.core/tree-map-seq-push, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([node stack ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7778, :end-line 7778, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node stack ascending?]))}, namespace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3312, :column 7, :end-line 3312, :end-column 16, :arglists (quote ([x])), :doc "Returns the namespace String of a symbol or keyword, or nil if not present."}, :name cljs.core/namespace, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3312, :end-line 3312, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns the namespace String of a symbol or keyword, or nil if not present."}, empty-unordered-hash {:name cljs.core/empty-unordered-hash, :file "cljs/core.cljs", :line 1339, :column 1, :end-line 1339, :end-column 36, :private true, :meta {:file "cljs/core.cljs", :line 1339, :column 16, :end-line 1339, :end-column 36, :private true}, :tag number}, obj-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8519, :column 7, :end-line 8519, :end-column 14, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new object map with supplied mappings.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name cljs.core/obj-map, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8519, :end-line 8519, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new object map with supplied mappings."}, Reduced {:num-fields 1, :protocols #{cljs.core/IDeref}, :name cljs.core/Reduced, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 1405, :record false, :end-line 1405, :skip-protocol-flag #{cljs.core/IDeref}}, -conj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 571, :column 9, :end-line 571, :end-column 14, :tag clj, :protocol cljs.core/ICollection, :doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)", :arglists (quote ([coll o]))}, :protocol cljs.core/ICollection, :name cljs.core/-conj, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 569, :ret-tag clj, :end-line 571, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll o])), :doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)"}, NodeSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/NodeSeq, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 7341, :record false, :end-line 7341, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, = {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1246, :column 16, :end-line 1246, :end-column 17, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/=, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1246, :ret-tag boolean, :end-line 1246, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison."}, ITransientMap {:meta {:file "cljs/core.cljs", :line 787, :column 14, :end-line 787, :end-column 27, :doc "Protocol for adding mapping functionality to transient collections.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-dissoc! [[tcoll key]]}}}, :protocol-symbol true, :name cljs.core/ITransientMap, :file "cljs/core.cljs", :end-column 27, :column 1, :line 787, :protocol-info {:methods {-dissoc! [[tcoll key]]}}, :info nil, :end-line 787, :tag any, :impls #{cljs.core/TransientHashMap cljs.core/TransientArrayMap}, :doc "Protocol for adding mapping functionality to transient collections.", :jsdoc ("@interface")}, push-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5070, :column 8, :end-line 5070, :end-column 17, :private true, :arglists (quote ([pv level parent tailnode]))}, :private true, :name cljs.core/push-tail, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pv level parent tailnode]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5070, :end-line 5070, :max-fixed-arity 4, :fn-var true, :arglists (quote ([pv level parent tailnode]))}, take {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4658, :column 7, :end-line 4658, :end-column 11, :arglists (quote ([n] [n coll])), :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/take, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4658, :end-line 4658, :max-fixed-arity 2, :fn-var true, :arglists ([n] [n coll]), :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided."}, vector? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2131, :column 16, :end-line 2131, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies IVector"}, :name cljs.core/vector?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2131, :ret-tag boolean, :end-line 2131, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IVector"}, array-index-of-equiv? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6265, :column 8, :end-line 6265, :end-column 29, :private true, :arglists (quote ([arr k]))}, :private true, :name cljs.core/array-index-of-equiv?, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6265, :end-line 6265, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, bitmap-indexed-node-index {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6803, :column 8, :end-line 6803, :end-column 33, :private true, :arglists (quote ([bitmap bit]))}, :private true, :name cljs.core/bitmap-indexed-node-index, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([bitmap bit]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6803, :end-line 6803, :max-fixed-arity 2, :fn-var true, :arglists (quote ([bitmap bit]))}, boolean {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2214, :column 16, :end-line 2214, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Coerce to boolean"}, :name cljs.core/boolean, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2214, :ret-tag boolean, :end-line 2214, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Coerce to boolean"}, IChunk {:meta {:file "cljs/core.cljs", :line 810, :column 14, :end-line 810, :end-column 20, :doc "Protocol for accessing the items of a chunk.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-drop-first [[coll]]}}}, :protocol-symbol true, :name cljs.core/IChunk, :file "cljs/core.cljs", :end-column 20, :column 1, :line 810, :protocol-info {:methods {-drop-first [[coll]]}}, :info nil, :end-line 810, :tag any, :impls #{cljs.core/ArrayChunk}, :doc "Protocol for accessing the items of a chunk.", :jsdoc ("@interface")}, bit-shift-left {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2863, :column 7, :end-line 2863, :end-column 21, :arglists (quote ([x n])), :doc "Bitwise shift left"}, :name cljs.core/bit-shift-left, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2863, :end-line 2863, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift left"}, random-uuid {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10774, :column 7, :end-line 10774, :end-column 18, :arglists (quote ([]))}, :name cljs.core/random-uuid, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10774, :end-line 10774, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, any? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 263, :column 16, :end-line 263, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Returns true if given any argument."}, :name cljs.core/any?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 263, :ret-tag boolean, :end-line 263, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if given any argument."}, rand-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10310, :column 7, :end-line 10310, :end-column 15, :arglists (quote ([n])), :doc "Returns a random integer between 0 (inclusive) and n (exclusive)."}, :name cljs.core/rand-int, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10310, :end-line 10310, :max-fixed-arity 1, :fn-var true, :arglists (quote ([n])), :doc "Returns a random integer between 0 (inclusive) and n (exclusive)."}, aclone {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 414, :column 7, :end-line 414, :end-column 13, :arglists (quote ([arr])), :doc "Returns a javascript array, cloned from the passed in array"}, :name cljs.core/aclone, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 414, :end-line 414, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr])), :doc "Returns a javascript array, cloned from the passed in array"}, BlackNode {:meta {:file "cljs/core.cljs", :line 7857, :column 18, :end-line 7857, :end-column 27, :declared true}, :num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/BlackNode, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 7957, :record false, :declared true, :end-line 7957, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, vreset! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4492, :column 7, :end-line 4492, :end-column 14, :arglists (quote ([vol newval])), :doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval."}, :name cljs.core/vreset!, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([vol newval]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4492, :end-line 4492, :max-fixed-arity 2, :fn-var true, :arglists (quote ([vol newval])), :doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval."}, chunk {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3580, :column 7, :end-line 3580, :end-column 12, :arglists (quote ([b]))}, :name cljs.core/chunk, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3580, :end-line 3580, :max-fixed-arity 1, :fn-var true, :arglists (quote ([b]))}, dec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2645, :column 7, :end-line 2645, :end-column 10, :arglists (quote ([x])), :doc "Returns a number one less than num."}, :name cljs.core/dec, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2645, :end-line 2645, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one less than num."}, ->TransformerIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4084, :column 10, :end-line 4084, :end-column 29, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([buffer _next completed xf sourceIter multi]))}, :protocols #{cljs.core/Object}, :name cljs.core/->TransformerIterator, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([buffer _next completed xf sourceIter multi]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 4084, :end-line 4084, :max-fixed-arity 6, :fn-var true, :arglists (quote ([buffer _next completed xf sourceIter multi])), :skip-protocol-flag nil}, APersistentVector {:meta {:file "cljs/core.cljs", :line 5175, :column 14, :end-line 5175, :end-column 31, :doc "Marker protocol", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/APersistentVector, :file "cljs/core.cljs", :end-column 31, :column 1, :line 5175, :protocol-info {:methods {}}, :info nil, :end-line 5175, :tag any, :impls #{cljs.core/PersistentVector}, :doc "Marker protocol", :jsdoc ("@interface")}, map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4611, :column 7, :end-line 4611, :end-column 10, :arglists (quote ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f] [f coll] [f c1 c2] [f c1 c2 c3]), :arglists ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/map, :variadic true, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f] [f coll] [f c1 c2] [f c1 c2 c3]), :arglists ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :arglists-meta (nil nil nil nil nil)}, :method-params ([f] [f coll] [f c1 c2] [f c1 c2 c3]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 4611, :end-line 4611, :max-fixed-arity 4, :fn-var true, :arglists ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided."}, juxt {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9438, :column 7, :end-line 9438, :end-column 11, :arglists (quote ([f] [f g] [f g h] [f g h & fs])), :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([f] [f g] [f g h]), :arglists ([f] [f g] [f g h] [f g h & fs]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/juxt, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([f] [f g] [f g h]), :arglists ([f] [f g] [f g h] [f g h & fs]), :arglists-meta (nil nil nil nil)}, :method-params ([f] [f g] [f g h]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 9438, :end-line 9438, :max-fixed-arity 3, :fn-var true, :arglists ([f] [f g] [f g h] [f g h & fs]), :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]"}, ->PersistentQueueIter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5857, :column 10, :end-line 5857, :end-column 29, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([fseq riter]))}, :protocols #{cljs.core/Object}, :name cljs.core/->PersistentQueueIter, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([fseq riter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5857, :end-line 5857, :max-fixed-arity 2, :fn-var true, :arglists (quote ([fseq riter])), :skip-protocol-flag nil}, < {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2597, :column 16, :end-line 2597, :end-column 17, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/<, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2597, :ret-tag boolean, :end-line 2597, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false."}, inode-kv-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6820, :column 8, :end-line 6820, :end-column 23, :private true, :arglists (quote ([arr f init]))}, :private true, :name cljs.core/inode-kv-reduce, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([arr f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6820, :end-line 6820, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr f init]))}, obj-map->hash-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6048, :column 8, :end-line 6048, :end-column 25, :private true, :arglists (quote ([m k v]))}, :private true, :name cljs.core/obj-map->hash-map, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([m k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6048, :end-line 6048, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m k v]))}, test {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10875, :column 7, :end-line 10875, :end-column 11, :arglists (quote ([v])), :doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception"}, :name cljs.core/test, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10875, :end-line 10875, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception"}, rest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1224, :column 12, :end-line 1224, :end-column 16, :tag seq, :arglists (quote ([coll])), :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument."}, :name cljs.core/rest, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1224, :ret-tag seq, :end-line 1224, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument."}, ex-data {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10839, :column 7, :end-line 10839, :end-column 14, :arglists (quote ([ex])), :doc "Returns exception data (a map) if ex is an ExceptionInfo.\n  Otherwise returns nil."}, :name cljs.core/ex-data, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10839, :end-line 10839, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Returns exception data (a map) if ex is an ExceptionInfo.\n  Otherwise returns nil."}, PersistentArrayMapSeq {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/PersistentArrayMapSeq, :file "cljs/core.cljs", :end-column 31, :type true, :column 10, :line 6398, :record false, :end-line 6398, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -drop-first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 812, :column 4, :end-line 812, :end-column 15, :protocol cljs.core/IChunk, :doc "Return a new chunk of coll with the first item removed.", :arglists (quote ([coll]))}, :protocol cljs.core/IChunk, :name cljs.core/-drop-first, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 810, :end-line 812, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a new chunk of coll with the first item removed."}, isa? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10350, :column 16, :end-line 10350, :end-column 20, :tag boolean, :arglists (quote ([child parent] [h child parent])), :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([child parent] [h child parent]), :arglists ([child parent] [h child parent]), :arglists-meta (nil nil)}}, :name cljs.core/isa?, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([child parent] [h child parent]), :arglists ([child parent] [h child parent]), :arglists-meta (nil nil)}, :method-params ([child parent] [h child parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10350, :ret-tag boolean, :end-line 10350, :max-fixed-arity 3, :tag boolean, :fn-var true, :arglists ([child parent] [h child parent]), :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy"}, boolean? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2190, :column 16, :end-line 2190, :end-column 24, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a Boolean"}, :name cljs.core/boolean?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2190, :ret-tag boolean, :end-line 2190, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a Boolean"}, -clone {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 555, :column 9, :end-line 555, :end-column 15, :tag clj, :protocol cljs.core/ICloneable, :doc "Creates a clone of value.", :arglists (quote ([value]))}, :protocol cljs.core/ICloneable, :name cljs.core/-clone, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 553, :ret-tag clj, :end-line 555, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([value])), :doc "Creates a clone of value."}, munge {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10984, :column 7, :end-line 10984, :end-column 12, :arglists (quote ([name]))}, :name cljs.core/munge, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10984, :end-line 10984, :max-fixed-arity 1, :fn-var true, :arglists (quote ([name]))}, empty-ordered-hash {:name cljs.core/empty-ordered-hash, :file "cljs/core.cljs", :line 1324, :column 1, :end-line 1324, :end-column 34, :private true, :meta {:file "cljs/core.cljs", :line 1324, :column 16, :end-line 1324, :end-column 34, :private true}, :tag number}, DEMUNGE_MAP {:name cljs.core/DEMUNGE_MAP, :file "cljs/core.cljs", :line 350, :column 1, :end-line 351, :end-column 14, :jsdoc ["@enum {string}"], :meta {:file "cljs/core.cljs", :line 351, :column 3, :end-line 351, :end-column 14, :jsdoc ["@enum {string}"]}, :tag object}, ES6IteratorSeq {:num-fields 3, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :name cljs.core/ES6IteratorSeq, :file "cljs/core.cljs", :end-column 24, :type true, :column 10, :line 1281, :record false, :end-line 1281, :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}}, ->NeverEquiv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5997, :column 10, :end-line 5997, :end-column 20, :protocols #{cljs.core/IEquiv cljs.core/Object}, :skip-protocol-flag #{cljs.core/IEquiv}, :factory :positional, :arglists (quote ([]))}, :protocols #{cljs.core/IEquiv cljs.core/Object}, :name cljs.core/->NeverEquiv, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5997, :end-line 5997, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :skip-protocol-flag #{cljs.core/IEquiv}}, re-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9534, :column 7, :end-line 9534, :end-column 13, :arglists (quote ([re s])), :doc "Returns a lazy sequence of successive matches of re in s."}, :name cljs.core/re-seq, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9534, :end-line 9534, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns a lazy sequence of successive matches of re in s."}, char? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 258, :column 16, :end-line 258, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript string of length one."}, :name cljs.core/char?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 258, :ret-tag boolean, :end-line 258, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript string of length one."}, make-hierarchy {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10333, :column 7, :end-line 10333, :end-column 21, :arglists (quote ([])), :doc "Creates a hierarchy object for use with derive, isa? etc."}, :name cljs.core/make-hierarchy, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10333, :end-line 10333, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Creates a hierarchy object for use with derive, isa? etc."}, Symbol {:meta {:file "cljs/core.cljs", :line 940, :column 15, :end-line 940, :end-column 21, :declared true}, :num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :name cljs.core/Symbol, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 1048, :record false, :declared true, :end-line 1048, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}}, PROTOCOL_SENTINEL {:name cljs.core/PROTOCOL_SENTINEL, :file "cljs/core.cljs", :line 36, :column 1, :end-line 36, :end-column 27, :meta {:file "cljs/core.cljs", :line 36, :column 10, :end-line 36, :end-column 27}, :tag object}, tv-push-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5682, :column 8, :end-line 5682, :end-column 20, :private true, :arglists (quote ([tv level parent tail-node]))}, :private true, :name cljs.core/tv-push-tail, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([tv level parent tail-node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5682, :end-line 5682, :max-fixed-arity 4, :fn-var true, :arglists (quote ([tv level parent tail-node]))}, -reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 680, :column 4, :end-line 680, :end-column 11, :protocol cljs.core/IReduce, :doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc.", :arglists (quote ([coll f] [coll f start])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll f] [coll f start]), :arglists ([coll f] [coll f start]), :arglists-meta (nil nil)}}, :protocol cljs.core/IReduce, :name cljs.core/-reduce, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll f] [coll f start]), :arglists ([coll f] [coll f start]), :arglists-meta (nil nil)}, :method-params ([coll f] [coll f start]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 677, :end-line 680, :max-fixed-arity 3, :fn-var true, :arglists ([coll f] [coll f start]), :doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc."}, -count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 560, :column 12, :end-line 560, :end-column 18, :tag number, :protocol cljs.core/ICounted, :doc "Calculates the count of coll in constant time. Used by cljs.core/count.", :arglists (quote ([coll]))}, :protocol cljs.core/ICounted, :name cljs.core/-count, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 558, :ret-tag number, :end-line 560, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Calculates the count of coll in constant time. Used by cljs.core/count."}, keep {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4328, :column 7, :end-line 4328, :end-column 11, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name cljs.core/keep, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4328, :end-line 4328, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided."}, char {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2665, :column 7, :end-line 2665, :end-column 11, :arglists (quote ([x])), :doc "Coerce to char"}, :name cljs.core/char, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2665, :end-line 2665, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to char"}, mapcat {:protocol-inline nil, :meta {:added "1.0", :file "cljs/core.cljs", :end-column 13, :static true, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([f]), :arglists ([f] [f & colls]), :arglists-meta (nil nil)}, :column 7, :line 4834, :end-line 4834, :arglists (quote ([f] [f & colls])), :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided"}, :added "1.0", :name cljs.core/mapcat, :variadic true, :file "cljs/core.cljs", :end-column 13, :static true, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([f]), :arglists ([f] [f & colls]), :arglists-meta (nil nil)}, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4834, :end-line 4834, :max-fixed-arity 1, :fn-var true, :arglists ([f] [f & colls]), :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided"}, unchecked-long {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2779, :column 7, :end-line 2779, :end-column 21, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, :name cljs.core/unchecked-long, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2779, :end-line 2779, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, m3-seed {:name cljs.core/m3-seed, :file "cljs/core.cljs", :line 898, :column 1, :end-line 898, :end-column 13, :meta {:file "cljs/core.cljs", :line 898, :column 6, :end-line 898, :end-column 13}, :tag number}, some? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 242, :column 16, :end-line 242, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is not nil, false otherwise."}, :name cljs.core/some?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 242, :ret-tag boolean, :end-line 242, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is not nil, false otherwise."}, unchecked-negate {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2734, :column 7, :end-line 2734, :end-column 23, :arglists (quote ([x]))}, :name cljs.core/unchecked-negate, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2734, :end-line 2734, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, symbol-identical? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3303, :column 16, :end-line 3303, :end-column 33, :tag boolean, :arglists (quote ([x y])), :doc "Efficient test to determine that two symbols are identical."}, :name cljs.core/symbol-identical?, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3303, :ret-tag boolean, :end-line 3303, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x y])), :doc "Efficient test to determine that two symbols are identical."}, *command-line-args* {:name cljs.core/*command-line-args*, :file "cljs/core.cljs", :line 288, :column 1, :end-line 291, :end-column 22, :doc "A sequence of the supplied command line arguments, or nil if\n  none were supplied", :meta {:file "cljs/core.cljs", :line 291, :column 3, :end-line 291, :end-column 22, :doc "A sequence of the supplied command line arguments, or nil if\n  none were supplied"}, :tag clj-nil}, reverse {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3157, :column 7, :end-line 3157, :end-column 14, :arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reverse order. Not lazy."}, :name cljs.core/reverse, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3157, :end-line 3157, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reverse order. Not lazy."}, inst? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1377, :column 16, :end-line 1377, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies Inst"}, :name cljs.core/inst?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1377, :ret-tag boolean, :end-line 1377, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies Inst"}, range {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9337, :column 7, :end-line 9337, :end-column 12, :arglists (quote ([] [end] [start end] [start end step])), :doc "Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([] [end] [start end] [start end step]), :arglists ([] [end] [start end] [start end step]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/range, :variadic false, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([] [end] [start end] [start end step]), :arglists ([] [end] [start end] [start end step]), :arglists-meta (nil nil nil nil)}, :method-params ([] [end] [start end] [start end step]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 9337, :end-line 9337, :max-fixed-arity 3, :fn-var true, :arglists ([] [end] [start end] [start end step]), :doc "Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity."}, bit-count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2879, :column 7, :end-line 2879, :end-column 16, :arglists (quote ([v])), :doc "Counts the number of bits set in n"}, :name cljs.core/bit-count, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2879, :end-line 2879, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "Counts the number of bits set in n"}, create-node {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7323, :column 8, :end-line 7323, :end-column 19, :private true, :arglists (quote ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2])), :top-fn {:variadic false, :max-fixed-arity 7, :method-params ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :arglists ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/create-node, :variadic false, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 7, :method-params ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :arglists ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :arglists-meta (nil nil)}, :method-params ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7323, :end-line 7323, :max-fixed-arity 7, :fn-var true, :arglists ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2])}, sort {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2401, :column 7, :end-line 2401, :end-column 11, :arglists (quote ([coll] [comp coll])), :doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [comp coll]), :arglists ([coll] [comp coll]), :arglists-meta (nil nil)}}, :name cljs.core/sort, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [comp coll]), :arglists ([coll] [comp coll]), :arglists-meta (nil nil)}, :method-params ([coll] [comp coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2401, :end-line 2401, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [comp coll]), :doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare."}, ->MetaFn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1981, :column 10, :end-line 1981, :end-column 16, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([afn meta]))}, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :name cljs.core/->MetaFn, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([afn meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1981, :end-line 1981, :max-fixed-arity 2, :fn-var true, :arglists (quote ([afn meta])), :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}}, unchecked-inc-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2717, :column 7, :end-line 2717, :end-column 24, :arglists (quote ([x]))}, :name cljs.core/unchecked-inc-int, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2717, :end-line 2717, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, -compare {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 806, :column 12, :end-line 806, :end-column 20, :tag number, :protocol cljs.core/IComparable, :doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y.", :arglists (quote ([x y]))}, :protocol cljs.core/IComparable, :name cljs.core/-compare, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 804, :ret-tag number, :end-line 806, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x y])), :doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y."}, map-indexed {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4300, :column 7, :end-line 4300, :end-column 18, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name cljs.core/map-indexed, :variadic false, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4300, :end-line 4300, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided."}, array-list {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9140, :column 7, :end-line 9140, :end-column 17, :arglists (quote ([]))}, :name cljs.core/array-list, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9140, :end-line 9140, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, rand-nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10314, :column 7, :end-line 10314, :end-column 15, :arglists (quote ([coll])), :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection."}, :name cljs.core/rand-nth, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10314, :end-line 10314, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection."}, comp {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4217, :column 7, :end-line 4217, :end-column 11, :arglists (quote ([] [f] [f g] [f g h] [f1 f2 f3 & fs])), :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([] [f] [f g] [f g h]), :arglists ([] [f] [f g] [f g h] [f1 f2 f3 & fs]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/comp, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([] [f] [f g] [f g h]), :arglists ([] [f] [f g] [f g h] [f1 f2 f3 & fs]), :arglists-meta (nil nil nil nil nil)}, :method-params ([] [f] [f g] [f g h]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 4217, :end-line 4217, :max-fixed-arity 3, :fn-var true, :arglists ([] [f] [f g] [f g h] [f1 f2 f3 & fs]), :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc."}, array-chunk {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3492, :column 7, :end-line 3492, :end-column 18, :arglists (quote ([arr] [arr off] [arr off end])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([arr] [arr off] [arr off end]), :arglists ([arr] [arr off] [arr off end]), :arglists-meta (nil nil nil)}}, :name cljs.core/array-chunk, :variadic false, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([arr] [arr off] [arr off end]), :arglists ([arr] [arr off] [arr off end]), :arglists-meta (nil nil nil)}, :method-params ([arr] [arr off] [arr off end]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 3492, :end-line 3492, :max-fixed-arity 3, :fn-var true, :arglists ([arr] [arr off] [arr off end])}, dispatch-fn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10737, :column 7, :end-line 10737, :end-column 18, :arglists (quote ([multifn])), :doc "Given a multimethod, return it's dispatch-fn."}, :name cljs.core/dispatch-fn, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10737, :end-line 10737, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, return it's dispatch-fn."}, bit-shift-right-zero-fill {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2871, :column 7, :end-line 2871, :end-column 32, :arglists (quote ([x n])), :doc "DEPRECATED: Bitwise shift right with zero fill"}, :name cljs.core/bit-shift-right-zero-fill, :variadic false, :file "cljs/core.cljs", :end-column 32, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2871, :end-line 2871, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "DEPRECATED: Bitwise shift right with zero fill"}, js-reserved? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10949, :column 8, :end-line 10949, :end-column 20, :private true, :arglists (quote ([x]))}, :private true, :name cljs.core/js-reserved?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10949, :end-line 10949, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, -as-transient {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 771, :column 9, :end-line 771, :end-column 22, :tag clj, :protocol cljs.core/IEditableCollection, :doc "Returns a new, transient version of the collection, in constant time.", :arglists (quote ([coll]))}, :protocol cljs.core/IEditableCollection, :name cljs.core/-as-transient, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 769, :ret-tag clj, :end-line 771, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time."}, dorun {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9474, :column 7, :end-line 9474, :end-column 12, :arglists (quote ([coll] [n coll])), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [n coll]), :arglists ([coll] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/dorun, :variadic false, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [n coll]), :arglists ([coll] [n coll]), :arglists-meta (nil nil)}, :method-params ([coll] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9474, :end-line 9474, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [n coll]), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil."}, pr-sequential-writer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9554, :column 7, :end-line 9554, :end-column 27, :arglists (quote ([writer print-one begin sep end opts coll]))}, :name cljs.core/pr-sequential-writer, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([writer print-one begin sep end opts coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9554, :end-line 9554, :max-fixed-arity 7, :fn-var true, :arglists (quote ([writer print-one begin sep end opts coll]))}, simple-symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3331, :column 16, :end-line 3331, :end-column 30, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a symbol without a namespace"}, :name cljs.core/simple-symbol?, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3331, :ret-tag boolean, :end-line 3331, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a symbol without a namespace"}, accumulating-seq-count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1782, :column 8, :end-line 1782, :end-column 30, :private true, :arglists (quote ([coll]))}, :private true, :name cljs.core/accumulating-seq-count, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1782, :end-line 1782, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, IIndexed {:meta {:file "cljs/core.cljs", :line 580, :column 14, :end-line 580, :end-column 22, :doc "Protocol for collections to provide indexed-based access to their items.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-nth [[coll n] [coll n not-found]]}}}, :protocol-symbol true, :name cljs.core/IIndexed, :file "cljs/core.cljs", :end-column 22, :column 1, :line 580, :protocol-info {:methods {-nth [[coll n] [coll n not-found]]}}, :info nil, :end-line 580, :tag any, :impls #{cljs.core/TransientVector cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/MapEntry cljs.core/Subvec cljs.core/PersistentVector cljs.core/ArrayChunk cljs.core/Range cljs.core/RedNode}, :doc "Protocol for collections to provide indexed-based access to their items.", :jsdoc ("@interface")}, disj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2065, :column 7, :end-line 2065, :end-column 11, :arglists (quote ([coll] [coll k] [coll k & ks])), :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [coll k]), :arglists ([coll] [coll k] [coll k & ks]), :arglists-meta (nil nil nil)}}, :name cljs.core/disj, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [coll k]), :arglists ([coll] [coll k] [coll k & ks]), :arglists-meta (nil nil nil)}, :method-params ([coll] [coll k]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2065, :end-line 2065, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [coll k] [coll k & ks]), :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s)."}, MultiIterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/MultiIterator, :file "cljs/core.cljs", :end-column 23, :type true, :column 10, :line 4057, :record false, :end-line 4057, :skip-protocol-flag nil}, IPrintWithWriter {:meta {:file "cljs/core.cljs", :line 745, :column 14, :end-line 745, :end-column 30, :doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-pr-writer [[o writer opts]]}}}, :protocol-symbol true, :name cljs.core/IPrintWithWriter, :file "cljs/core.cljs", :end-column 30, :column 1, :line 745, :protocol-info {:methods {-pr-writer [[o writer opts]]}}, :info nil, :end-line 745, :tag any, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Volatile cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ExceptionInfo cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/TaggedLiteral cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/TransformerIterator cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append.", :jsdoc ("@interface")}, ->UUID {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10744, :column 10, :end-line 10744, :end-column 14, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/IComparable cljs.core/IUUID}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/IComparable}, :factory :positional, :arglists (quote ([uuid __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/IComparable cljs.core/IUUID}, :name cljs.core/->UUID, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([uuid __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 10744, :end-line 10744, :max-fixed-arity 2, :fn-var true, :arglists (quote ([uuid __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/IComparable}}, IVector {:meta {:file "cljs/core.cljs", :line 654, :column 14, :end-line 654, :end-column 21, :doc "Protocol for adding vector functionality to collections.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-assoc-n [[coll n val]]}}}, :protocol-symbol true, :name cljs.core/IVector, :file "cljs/core.cljs", :end-column 21, :column 1, :line 654, :protocol-info {:methods {-assoc-n [[coll n val]]}}, :info nil, :end-line 654, :tag any, :impls #{cljs.core/BlackNode cljs.core/MapEntry cljs.core/Subvec cljs.core/PersistentVector cljs.core/RedNode}, :doc "Protocol for adding vector functionality to collections.", :jsdoc ("@interface")}, IIterable {:meta {:file "cljs/core.cljs", :line 853, :column 14, :end-line 853, :end-column 23, :doc "Protocol for iterating over a collection.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-iterator [[coll]]}}}, :protocol-symbol true, :name cljs.core/IIterable, :file "cljs/core.cljs", :end-column 23, :column 1, :line 853, :protocol-info {:methods {-iterator [[coll]]}}, :info nil, :end-line 853, :tag any, :impls #{cljs.core/PersistentHashMap cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Subvec cljs.core/PersistentVector cljs.core/ArrayNode cljs.core/PersistentHashSet cljs.core/HashCollisionNode cljs.core/Range cljs.core/BitmapIndexedNode}, :doc "Protocol for iterating over a collection.", :jsdoc ("@interface")}, ->MultiIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4057, :column 10, :end-line 4057, :end-column 23, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([iters]))}, :protocols #{cljs.core/Object}, :name cljs.core/->MultiIterator, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([iters]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 4057, :end-line 4057, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iters])), :skip-protocol-flag nil}, *2 {:name cljs.core/*2, :file "cljs/core.cljs", :line 191, :column 1, :end-line 193, :end-column 5, :doc "bound in a repl thread to the second most recent value printed", :meta {:file "cljs/core.cljs", :line 193, :column 3, :end-line 193, :end-column 5, :doc "bound in a repl thread to the second most recent value printed"}}, Eduction {:num-fields 2, :protocols #{cljs.core/Object cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/Eduction, :file "cljs/core.cljs", :end-column 18, :type true, :column 10, :line 10156, :record false, :end-line 10156, :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}}, pv-clone-node {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5051, :column 8, :end-line 5051, :end-column 21, :private true, :arglists (quote ([node]))}, :private true, :name cljs.core/pv-clone-node, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5051, :end-line 5051, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, cons {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3238, :column 7, :end-line 3238, :end-column 11, :arglists (quote ([x coll])), :doc "Returns a new seq where x is the first element and coll is the rest."}, :name cljs.core/cons, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3238, :end-line 3238, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x coll])), :doc "Returns a new seq where x is the first element and coll is the rest."}, PersistentTreeSet {:num-fields 3, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/PersistentTreeSet, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 8910, :record false, :end-line 8910, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, ->HashSetIter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8745, :column 10, :end-line 8745, :end-column 21, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([iter]))}, :protocols #{cljs.core/Object}, :name cljs.core/->HashSetIter, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 8745, :end-line 8745, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iter])), :skip-protocol-flag nil}, ns-lookup {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11021, :column 8, :end-line 11021, :end-column 17, :private true, :arglists (quote ([ns-obj k])), :doc "Bootstrap only."}, :private true, :name cljs.core/ns-lookup, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([ns-obj k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 11021, :end-line 11021, :max-fixed-arity 2, :fn-var true, :arglists (quote ([ns-obj k])), :doc "Bootstrap only."}, floats {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2789, :column 7, :end-line 2789, :end-column 13, :arglists (quote ([x]))}, :name cljs.core/floats, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2789, :end-line 2789, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, TransientVector {:meta {:file "cljs/core.cljs", :line 5172, :column 44, :end-line 5172, :end-column 59, :declared true}, :num-fields 4, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientVector, :file "cljs/core.cljs", :end-column 25, :type true, :column 10, :line 5724, :record false, :declared true, :end-line 5724, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}}, pos? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2899, :column 16, :end-line 2899, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Returns true if num is greater than zero, else false"}, :name cljs.core/pos?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2899, :ret-tag boolean, :end-line 2899, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if num is greater than zero, else false"}, fnil {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4275, :column 7, :end-line 4275, :end-column 11, :arglists (quote ([f x] [f x y] [f x y z])), :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([f x] [f x y] [f x y z]), :arglists ([f x] [f x y] [f x y z]), :arglists-meta (nil nil nil)}}, :name cljs.core/fnil, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([f x] [f x y] [f x y z]), :arglists ([f x] [f x y] [f x y z]), :arglists-meta (nil nil nil)}, :method-params ([f x] [f x y] [f x y z]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 4275, :end-line 4275, :max-fixed-arity 4, :fn-var true, :arglists ([f x] [f x y] [f x y z]), :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched."}, merge-with {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8711, :column 7, :end-line 8711, :end-column 17, :arglists (quote ([f & maps])), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f maps)], :arglists ([f & maps]), :arglists-meta (nil)}}, :name cljs.core/merge-with, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f maps)], :arglists ([f & maps]), :arglists-meta (nil)}, :method-params [(f maps)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8711, :end-line 8711, :max-fixed-arity 1, :fn-var true, :arglists ([f & maps]), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter)."}, nthrest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1895, :column 7, :end-line 1895, :end-column 14, :arglists (quote ([coll n])), :doc "Returns the nth rest of coll, coll when n is 0."}, :name cljs.core/nthrest, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1895, :end-line 1895, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll n])), :doc "Returns the nth rest of coll, coll when n is 0."}, *warn-on-infer* {:name cljs.core/*warn-on-infer*, :file "cljs/core.cljs", :line 32, :column 1, :end-line 32, :end-column 21, :meta {:file "cljs/core.cljs", :line 32, :column 6, :end-line 32, :end-column 21}, :tag boolean}, -find {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 624, :column 4, :end-line 624, :end-column 9, :protocol cljs.core/IFind, :doc "Returns the map entry for key, or nil if key not present.", :arglists (quote ([coll k]))}, :protocol cljs.core/IFind, :name cljs.core/-find, :variadic false, :file "cljs/core.cljs", :end-column 9, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 622, :end-line 624, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll k])), :doc "Returns the map entry for key, or nil if key not present."}, sequential? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2107, :column 16, :end-line 2107, :end-column 27, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISequential"}, :name cljs.core/sequential?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2107, :ret-tag boolean, :end-line 2107, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISequential"}, tree-map-replace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8338, :column 8, :end-line 8338, :end-column 24, :private true, :arglists (quote ([comp tree k v]))}, :private true, :name cljs.core/tree-map-replace, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([comp tree k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8338, :end-line 8338, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp tree k v]))}, checked-aset' {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 476, :column 8, :end-line 476, :end-column 21, :private true, :arglists (quote ([array idx val] [array idx idx2 & idxv])), :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([array idx val]), :arglists ([array idx val] [array idx idx2 & idxv]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/checked-aset', :variadic true, :file "cljs/core.cljs", :end-column 21, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([array idx val]), :arglists ([array idx val] [array idx idx2 & idxv]), :arglists-meta (nil nil)}, :method-params ([array idx val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 476, :end-line 476, :max-fixed-arity 3, :fn-var true, :arglists ([array idx val] [array idx idx2 & idxv])}, m3-mix-H1 {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 905, :column 15, :end-line 905, :end-column 24, :tag number, :arglists (quote ([h1 k1]))}, :name cljs.core/m3-mix-H1, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([h1 k1]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 905, :ret-tag number, :end-line 905, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([h1 k1]))}, RecordIter {:num-fields 5, :protocols #{cljs.core/Object}, :name cljs.core/RecordIter, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 6189, :record false, :end-line 6189, :skip-protocol-flag nil}, ->TransientArrayMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6696, :column 10, :end-line 6696, :end-column 27, :protocols #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :factory :positional, :arglists (quote ([editable? len arr]))}, :protocols #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientArrayMap, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([editable? len arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6696, :end-line 6696, :max-fixed-arity 3, :fn-var true, :arglists (quote ([editable? len arr])), :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, prim-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1644, :column 7, :end-line 1644, :end-column 15, :arglists (quote ([prim] [prim i])), :doc "Create seq from a primitive JavaScript Array-like.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([prim] [prim i]), :arglists ([prim] [prim i]), :arglists-meta (nil nil)}}, :name cljs.core/prim-seq, :variadic false, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([prim] [prim i]), :arglists ([prim] [prim i]), :arglists-meta (nil nil)}, :method-params ([prim] [prim i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1644, :end-line 1644, :max-fixed-arity 2, :fn-var true, :arglists ([prim] [prim i]), :doc "Create seq from a primitive JavaScript Array-like."}, *print-level* {:meta {:file "cljs/core.cljs", :line 153, :column 3, :end-line 153, :end-column 16, :dynamic true, :doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.", :jsdoc ["@type {null|number}"]}, :name cljs.core/*print-level*, :file "cljs/core.cljs", :end-column 16, :column 1, :dynamic true, :line 142, :end-line 153, :tag clj-nil, :doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.", :jsdoc ["@type {null|number}"]}, shuffle {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2442, :column 7, :end-line 2442, :end-column 14, :arglists (quote ([coll])), :doc "Return a random permutation of coll"}, :name cljs.core/shuffle, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2442, :end-line 2442, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a random permutation of coll"}, ChunkedSeq {:meta {:file "cljs/core.cljs", :line 2135, :column 22, :end-line 2135, :end-column 32, :declared true}, :num-fields 6, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ChunkedSeq, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 5418, :record false, :declared true, :end-line 5418, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, hash-keyword {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3246, :column 7, :end-line 3246, :end-column 19, :arglists (quote ([k]))}, :name cljs.core/hash-keyword, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3246, :end-line 3246, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, find {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2315, :column 7, :end-line 2315, :end-column 11, :arglists (quote ([coll k])), :doc "Returns the map entry for key, or nil if key not present."}, :name cljs.core/find, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2315, :end-line 2315, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll k])), :doc "Returns the map entry for key, or nil if key not present."}, alength {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 499, :column 15, :end-line 499, :end-column 22, :tag number, :arglists (quote ([array])), :doc "Returns the length of the array. Works on arrays of all types."}, :name cljs.core/alength, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([array]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 499, :ret-tag number, :end-line 499, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([array])), :doc "Returns the length of the array. Works on arrays of all types."}, bit-xor {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2815, :column 7, :end-line 2815, :end-column 14, :arglists (quote ([x y] [x y & more])), :doc "Bitwise exclusive or", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}}, :name cljs.core/bit-xor, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2815, :end-line 2815, :max-fixed-arity 2, :fn-var true, :arglists ([x y] [x y & more]), :doc "Bitwise exclusive or"}, ->IndexedSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1556, :column 10, :end-line 1556, :end-column 20, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([arr i meta]))}, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->IndexedSeq, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([arr i meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1556, :end-line 1556, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i meta])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, ObjMap {:num-fields 5, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/ObjMap, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 6072, :record false, :end-line 6072, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, unsigned-bit-shift-right {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2875, :column 7, :end-line 2875, :end-column 31, :arglists (quote ([x n])), :doc "Bitwise shift right with zero fill"}, :name cljs.core/unsigned-bit-shift-right, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2875, :end-line 2875, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift right with zero fill"}, ES6SetEntriesIterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6SetEntriesIterator, :file "cljs/core.cljs", :end-column 31, :type true, :column 10, :line 6215, :record false, :end-line 6215, :skip-protocol-flag nil}, neg? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2908, :column 16, :end-line 2908, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Returns true if num is less than zero, else false"}, :name cljs.core/neg?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2908, :ret-tag boolean, :end-line 2908, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if num is less than zero, else false"}, Cons {:num-fields 4, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/Cons, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 3181, :record false, :end-line 3181, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -remove-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10508, :column 4, :end-line 10508, :end-column 18, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf dispatch-val]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-remove-method, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([mf dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10505, :end-line 10508, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf dispatch-val])), :doc nil}, ->StringIter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3954, :column 10, :end-line 3954, :end-column 20, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([s i]))}, :protocols #{cljs.core/Object}, :name cljs.core/->StringIter, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([s i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3954, :end-line 3954, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s i])), :skip-protocol-flag nil}, js-invoke {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 514, :column 7, :end-line 514, :end-column 16, :arglists (quote ([obj s & args])), :doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(obj s args)], :arglists ([obj s & args]), :arglists-meta (nil)}}, :name cljs.core/js-invoke, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(obj s args)], :arglists ([obj s & args]), :arglists-meta (nil)}, :method-params [(obj s args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 514, :end-line 514, :max-fixed-arity 2, :fn-var true, :arglists ([obj s & args]), :doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name."}, ->List {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3004, :column 10, :end-line 3004, :end-column 14, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta first rest count __hash]))}, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->List, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([meta first rest count __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3004, :end-line 3004, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta first rest count __hash])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, m3-mix-K1 {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 902, :column 15, :end-line 902, :end-column 24, :tag number, :arglists (quote ([k1]))}, :name cljs.core/m3-mix-K1, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([k1]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 902, :ret-tag number, :end-line 902, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([k1]))}, unchecked-float {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2680, :column 15, :end-line 2680, :end-column 30, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-float, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2680, :ret-tag number, :end-line 2680, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, undefined? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2194, :column 16, :end-line 2194, :end-column 26, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x identical to the JavaScript undefined value."}, :name cljs.core/undefined?, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2194, :ret-tag boolean, :end-line 2194, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x identical to the JavaScript undefined value."}, IMeta {:meta {:file "cljs/core.cljs", :line 667, :column 14, :end-line 667, :end-column 19, :doc "Protocol for accessing the metadata of an object.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-meta [[o]]}}}, :protocol-symbol true, :name cljs.core/IMeta, :file "cljs/core.cljs", :end-column 19, :column 1, :line 667, :protocol-info {:methods {-meta [[o]]}}, :info nil, :end-line 667, :tag any, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet function cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/t_cljs$core14407 cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/MetaFn cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for accessing the metadata of an object.", :jsdoc ("@interface")}, reduced? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1414, :column 16, :end-line 1414, :end-column 24, :tag boolean, :arglists (quote ([r])), :doc "Returns true if x is the result of a call to reduced"}, :name cljs.core/reduced?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([r]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1414, :ret-tag boolean, :end-line 1414, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([r])), :doc "Returns true if x is the result of a call to reduced"}, apply-to {:protocol-inline nil, :meta {:arglists (quote ([f argc args])), :file "cljs/core.cljs"}, :name cljs.core/apply-to, :variadic false, :file "cljs/core.cljs", :method-params ([f argc args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3832, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f argc args]))}, disj! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3817, :column 7, :end-line 3817, :end-column 12, :arglists (quote ([tcoll val] [tcoll val & vals])), :doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([tcoll val]), :arglists ([tcoll val] [tcoll val & vals]), :arglists-meta (nil nil)}}, :name cljs.core/disj!, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([tcoll val]), :arglists ([tcoll val] [tcoll val & vals]), :arglists-meta (nil nil)}, :method-params ([tcoll val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3817, :end-line 3817, :max-fixed-arity 2, :fn-var true, :arglists ([tcoll val] [tcoll val & vals]), :doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s)."}, -lookup {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 609, :column 4, :end-line 609, :end-column 11, :protocol cljs.core/ILookup, :doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned.", :arglists (quote ([o k] [o k not-found])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([o k] [o k not-found]), :arglists ([o k] [o k not-found]), :arglists-meta (nil nil)}}, :protocol cljs.core/ILookup, :name cljs.core/-lookup, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([o k] [o k not-found]), :arglists ([o k] [o k not-found]), :arglists-meta (nil nil)}, :method-params ([o k] [o k not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 607, :end-line 609, :max-fixed-arity 3, :fn-var true, :arglists ([o k] [o k not-found]), :doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned."}, float? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2288, :column 16, :end-line 2288, :end-column 22, :tag boolean, :arglists (quote ([x])), :doc "Returns true for JavaScript numbers, false otherwise."}, :name cljs.core/float?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2288, :ret-tag boolean, :end-line 2288, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true for JavaScript numbers, false otherwise."}, ICloneable {:meta {:file "cljs/core.cljs", :line 553, :column 14, :end-line 553, :end-column 24, :doc "Protocol for cloning a value.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-clone [[value]]}}}, :protocol-symbol true, :name cljs.core/ICloneable, :file "cljs/core.cljs", :end-column 24, :column 1, :line 553, :protocol-info {:methods {-clone [[value]]}}, :info nil, :end-line 553, :tag any, :impls #{cljs.core/PersistentHashMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/Subvec cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/Range}, :doc "Protocol for cloning a value.", :jsdoc ("@interface")}, IEncodeClojure {:meta {:file "cljs/core.cljs", :line 10240, :column 14, :end-line 10240, :end-column 28, :doc nil, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-js->clj [[x options]]}}}, :protocol-symbol true, :name cljs.core/IEncodeClojure, :file "cljs/core.cljs", :end-column 28, :column 1, :line 10240, :protocol-info {:methods {-js->clj [[x options]]}}, :info nil, :end-line 10240, :tag any, :impls #{}, :doc nil, :jsdoc ("@interface")}, booleans {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2784, :column 7, :end-line 2784, :end-column 15, :arglists (quote ([x]))}, :name cljs.core/booleans, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2784, :end-line 2784, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, ->ArrayList {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9132, :column 10, :end-line 9132, :end-column 19, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([arr]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayList, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 9132, :end-line 9132, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr])), :skip-protocol-flag nil}, RSeq {:meta {:file "cljs/core.cljs", :line 1503, :column 40, :end-line 1503, :end-column 44, :declared true}, :num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/RSeq, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 1661, :record false, :declared true, :end-line 1661, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, mask {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6785, :column 8, :end-line 6785, :end-column 12, :private true, :arglists (quote ([hash shift]))}, :private true, :name cljs.core/mask, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([hash shift]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6785, :end-line 6785, :max-fixed-arity 2, :fn-var true, :arglists (quote ([hash shift]))}, int-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3617, :column 7, :end-line 3617, :end-column 16, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}}, :name cljs.core/int-array, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3617, :end-line 3617, :max-fixed-arity 2, :fn-var true, :arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure."}, find-and-cache-best-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10477, :column 8, :end-line 10477, :end-column 34, :private true, :arglists (quote ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy default-dispatch-val]))}, :private true, :name cljs.core/find-and-cache-best-method, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy default-dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10477, :end-line 10477, :max-fixed-arity 8, :fn-var true, :arglists (quote ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy default-dispatch-val]))}, set? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2092, :column 16, :end-line 2092, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x satisfies ISet"}, :name cljs.core/set?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2092, :ret-tag boolean, :end-line 2092, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x satisfies ISet"}, iterable? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1175, :column 16, :end-line 1175, :end-column 25, :tag boolean, :arglists (quote ([x])), :doc "Return true if x implements IIterable protocol."}, :name cljs.core/iterable?, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1175, :ret-tag boolean, :end-line 1175, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x implements IIterable protocol."}, cat {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10093, :column 7, :end-line 10093, :end-column 10, :arglists (quote ([rf])), :doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.", :added "1.7"}, :added "1.7", :name cljs.core/cat, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([rf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10093, :end-line 10093, :max-fixed-arity 1, :fn-var true, :arglists (quote ([rf])), :doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction."}, ->ES6EntriesIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6202, :column 10, :end-line 6202, :end-column 28, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([s]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ES6EntriesIterator, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6202, :end-line 6202, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil}, divide {:name cljs.core/divide, :file "cljs/core.cljs", :line 2588, :column 1, :end-line 2588, :end-column 16, :declared true, :meta {:file "cljs/core.cljs", :line 2588, :column 10, :end-line 2588, :end-column 16, :declared true}}, js-reserved-arr {:meta {:file "cljs/core.cljs", :line 10930, :column 3, :end-line 10930, :end-column 18, :private true, :jsdoc ["@type {*}"]}, :private true, :name cljs.core/js-reserved-arr, :file "cljs/core.cljs", :end-column 18, :column 1, :line 10927, :end-line 10930, :tag array, :jsdoc ["@type {*}"]}, -pr-writer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 751, :column 4, :end-line 751, :end-column 14, :protocol cljs.core/IPrintWithWriter, :doc nil, :arglists (quote ([o writer opts]))}, :protocol cljs.core/IPrintWithWriter, :name cljs.core/-pr-writer, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([o writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 745, :end-line 751, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o writer opts])), :doc nil}, flush {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9587, :column 7, :end-line 9587, :end-column 12, :arglists (quote ([]))}, :name cljs.core/flush, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9587, :end-line 9587, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, set-from-indexed-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9005, :column 7, :end-line 9005, :end-column 27, :arglists (quote ([iseq]))}, :name cljs.core/set-from-indexed-seq, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([iseq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9005, :end-line 9005, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iseq]))}, take-while {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9174, :column 7, :end-line 9174, :end-column 17, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name cljs.core/take-while, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9174, :end-line 9174, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."}, vary-meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3920, :column 7, :end-line 3920, :end-column 16, :arglists (quote ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args])), :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d]), :arglists ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args]), :arglists-meta (nil nil nil nil nil nil)}}, :name cljs.core/vary-meta, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d]), :arglists ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args]), :arglists-meta (nil nil nil nil nil nil)}, :method-params ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil nil), :column 1, :line 3920, :end-line 3920, :max-fixed-arity 6, :fn-var true, :arglists ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args]), :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata."}, INext {:meta {:file "cljs/core.cljs", :line 599, :column 14, :end-line 599, :end-column 19, :doc "Protocol for accessing the next items of a collection.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-next [[coll]]}}}, :protocol-symbol true, :name cljs.core/INext, :file "cljs/core.cljs", :end-column 19, :column 1, :line 599, :protocol-info {:methods {-next [[coll]]}}, :info nil, :end-line 599, :tag any, :impls #{cljs.core/Cons cljs.core/NodeSeq cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/LazySeq cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/Range cljs.core/PersistentTreeMapSeq}, :doc "Protocol for accessing the next items of a collection.", :jsdoc ("@interface")}, is_proto_ {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 278, :column 7, :end-line 278, :end-column 16, :arglists (quote ([x]))}, :name cljs.core/is_proto_, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 278, :end-line 278, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, START {:name cljs.core/START, :file "cljs/core.cljs", :line 3979, :column 1, :end-line 3979, :end-column 11, :meta {:file "cljs/core.cljs", :line 3979, :column 6, :end-line 3979, :end-column 11}, :tag object}, ICounted {:meta {:file "cljs/core.cljs", :line 558, :column 14, :end-line 558, :end-column 22, :doc "Protocol for adding the ability to count a collection in constant time.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-count [[coll]]}}}, :protocol-symbol true, :name cljs.core/ICounted, :file "cljs/core.cljs", :end-column 22, :column 1, :line 558, :protocol-info {:methods {-count [[coll]]}}, :info nil, :end-line 558, :tag any, :impls #{nil cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/Subvec cljs.core/TransientHashMap cljs.core/ChunkBuffer cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/TransientArrayMap cljs.core/RSeq cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/ArrayChunk cljs.core/PersistentTreeSet cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding the ability to count a collection in constant time.", :jsdoc ("@interface")}, IMapEntry {:meta {:file "cljs/core.cljs", :line 632, :column 14, :end-line 632, :end-column 23, :doc "Protocol for examining a map entry.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-key [[coll]], -val [[coll]]}}}, :protocol-symbol true, :name cljs.core/IMapEntry, :file "cljs/core.cljs", :end-column 23, :column 1, :line 632, :protocol-info {:methods {-key [[coll]], -val [[coll]]}}, :info nil, :end-line 632, :tag any, :impls #{cljs.core/BlackNode cljs.core/MapEntry cljs.core/PersistentVector cljs.core/RedNode}, :doc "Protocol for examining a map entry.", :jsdoc ("@interface")}, pv-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5156, :column 8, :end-line 5156, :end-column 17, :private true, :arglists (quote ([pv f start end] [pv f init start end])), :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([pv f start end] [pv f init start end]), :arglists ([pv f start end] [pv f init start end]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/pv-reduce, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([pv f start end] [pv f init start end]), :arglists ([pv f start end] [pv f init start end]), :arglists-meta (nil nil)}, :method-params ([pv f start end] [pv f init start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5156, :end-line 5156, :max-fixed-arity 5, :fn-var true, :arglists ([pv f start end] [pv f init start end])}, <= {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2609, :column 16, :end-line 2609, :end-column 18, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/<=, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2609, :ret-tag boolean, :end-line 2609, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false."}, MODULE_INFOS {:name cljs.core/MODULE_INFOS, :file "cljs/core.cljs", :line 39, :column 1, :end-line 39, :end-column 18, :meta {:file "cljs/core.cljs", :line 39, :column 6, :end-line 39, :end-column 18}, :tag clj-nil}, conj! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3776, :column 7, :end-line 3776, :end-column 12, :arglists (quote ([] [tcoll] [tcoll val] [tcoll val & vals])), :doc "Adds val to the transient collection, and return tcoll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [tcoll] [tcoll val]), :arglists ([] [tcoll] [tcoll val] [tcoll val & vals]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/conj!, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [tcoll] [tcoll val]), :arglists ([] [tcoll] [tcoll val] [tcoll val & vals]), :arglists-meta (nil nil nil nil)}, :method-params ([] [tcoll] [tcoll val]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 3776, :end-line 3776, :max-fixed-arity 2, :fn-var true, :arglists ([] [tcoll] [tcoll val] [tcoll val & vals]), :doc "Adds val to the transient collection, and return tcoll. The 'addition'\n  may happen at different 'places' depending on the concrete type."}, -pop {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 650, :column 9, :end-line 650, :end-column 13, :tag clj, :protocol cljs.core/IStack, :doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop.", :arglists (quote ([coll]))}, :protocol cljs.core/IStack, :name cljs.core/-pop, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 644, :ret-tag clj, :end-line 650, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop."}, array-index-of-identical? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6257, :column 8, :end-line 6257, :end-column 33, :private true, :arglists (quote ([arr k]))}, :private true, :name cljs.core/array-index-of-identical?, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6257, :end-line 6257, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, repeatedly {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4770, :column 7, :end-line 4770, :end-column 17, :arglists (quote ([f] [n f])), :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [n f]), :arglists ([f] [n f]), :arglists-meta (nil nil)}}, :name cljs.core/repeatedly, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [n f]), :arglists ([f] [n f]), :arglists-meta (nil nil)}, :method-params ([f] [n f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4770, :end-line 4770, :max-fixed-arity 2, :fn-var true, :arglists ([f] [n f]), :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it"}, zipmap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9106, :column 7, :end-line 9106, :end-column 13, :arglists (quote ([keys vals])), :doc "Returns a map with the keys mapped to the corresponding vals."}, :name cljs.core/zipmap, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([keys vals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9106, :end-line 9106, :max-fixed-arity 2, :fn-var true, :arglists (quote ([keys vals])), :doc "Returns a map with the keys mapped to the corresponding vals."}, IStack {:meta {:file "cljs/core.cljs", :line 644, :column 14, :end-line 644, :end-column 20, :doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-peek [[coll]], -pop [[coll]]}}}, :protocol-symbol true, :name cljs.core/IStack, :file "cljs/core.cljs", :end-column 20, :column 1, :line 644, :protocol-info {:methods {-peek [[coll]], -pop [[coll]]}}, :info nil, :end-line 644, :tag any, :impls #{cljs.core/PersistentQueue cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/Subvec cljs.core/PersistentVector cljs.core/List cljs.core/RedNode}, :doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures.", :jsdoc ("@interface")}, -remove-watch {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 766, :column 4, :end-line 766, :end-column 17, :protocol cljs.core/IWatchable, :doc "Removes watcher that corresponds to key from this.", :arglists (quote ([this key]))}, :protocol cljs.core/IWatchable, :name cljs.core/-remove-watch, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([this key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 759, :end-line 766, :max-fixed-arity 2, :fn-var true, :arglists (quote ([this key])), :doc "Removes watcher that corresponds to key from this."}, IVolatile {:meta {:file "cljs/core.cljs", :line 847, :column 14, :end-line 847, :end-column 23, :doc "Protocol for adding volatile functionality.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-vreset! [[o new-value]]}}}, :protocol-symbol true, :name cljs.core/IVolatile, :file "cljs/core.cljs", :end-column 23, :column 1, :line 847, :protocol-info {:methods {-vreset! [[o new-value]]}}, :info nil, :end-line 847, :tag any, :impls #{cljs.core/Volatile}, :doc "Protocol for adding volatile functionality.", :jsdoc ("@interface")}, remove {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4873, :column 7, :end-line 4873, :end-column 13, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name cljs.core/remove, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4873, :end-line 4873, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."}, ->BitmapIndexedNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6876, :column 10, :end-line 6876, :end-column 27, :protocols #{cljs.core/Object cljs.core/IIterable}, :skip-protocol-flag #{cljs.core/IIterable}, :factory :positional, :arglists (quote ([edit bitmap arr]))}, :protocols #{cljs.core/Object cljs.core/IIterable}, :name cljs.core/->BitmapIndexedNode, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([edit bitmap arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6876, :end-line 6876, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit bitmap arr])), :skip-protocol-flag #{cljs.core/IIterable}}, * {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2581, :column 15, :end-line 2581, :end-column 16, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/*, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 2581, :ret-tag number, :end-line 2581, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the product of nums. (*) returns 1."}, re-pattern {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9543, :column 7, :end-line 9543, :end-column 17, :arglists (quote ([s])), :doc "Returns an instance of RegExp which has compiled the provided string."}, :name cljs.core/re-pattern, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9543, :end-line 9543, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Returns an instance of RegExp which has compiled the provided string."}, min {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2656, :column 15, :end-line 2656, :end-column 18, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns the least of the nums.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/min, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2656, :ret-tag number, :end-line 2656, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns the least of the nums."}, array-index-of-nil? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6229, :column 8, :end-line 6229, :end-column 27, :private true, :arglists (quote ([arr]))}, :private true, :name cljs.core/array-index-of-nil?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6229, :end-line 6229, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr]))}, -persistent! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 778, :column 9, :end-line 778, :end-column 21, :tag clj, :protocol cljs.core/ITransientCollection, :doc "Creates a persistent data structure from tcoll and returns it.", :arglists (quote ([tcoll]))}, :protocol cljs.core/ITransientCollection, :name cljs.core/-persistent!, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 774, :ret-tag clj, :end-line 778, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([tcoll])), :doc "Creates a persistent data structure from tcoll and returns it."}, -nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 582, :column 4, :end-line 582, :end-column 8, :protocol cljs.core/IIndexed, :doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied.", :arglists (quote ([coll n] [coll n not-found])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}}, :protocol cljs.core/IIndexed, :name cljs.core/-nth, :variadic false, :file "cljs/core.cljs", :end-column 8, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 580, :end-line 582, :max-fixed-arity 3, :fn-var true, :arglists ([coll n] [coll n not-found]), :doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied."}, pop! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3811, :column 7, :end-line 3811, :end-column 11, :arglists (quote ([tcoll])), :doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns tcoll"}, :name cljs.core/pop!, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3811, :end-line 3811, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tcoll])), :doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns tcoll"}, chunk-append {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3577, :column 7, :end-line 3577, :end-column 19, :arglists (quote ([b x]))}, :name cljs.core/chunk-append, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([b x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3577, :end-line 3577, :max-fixed-arity 2, :fn-var true, :arglists (quote ([b x]))}, *unchecked-arrays* {:name cljs.core/*unchecked-arrays*, :file "cljs/core.cljs", :line 29, :column 1, :end-line 29, :end-column 24, :meta {:file "cljs/core.cljs", :line 29, :column 6, :end-line 29, :end-column 24}, :tag boolean}, prn-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9754, :column 7, :end-line 9754, :end-column 14, :arglists (quote ([& objs])), :doc "Same as pr-str followed by (newline)", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/prn-str, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9754, :end-line 9754, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "Same as pr-str followed by (newline)"}, IReversible {:meta {:file "cljs/core.cljs", :line 716, :column 14, :end-line 716, :end-column 25, :doc "Protocol for reversing a seq.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-rseq [[coll]]}}}, :protocol-symbol true, :name cljs.core/IReversible, :file "cljs/core.cljs", :end-column 25, :column 1, :line 716, :protocol-info {:methods {-rseq [[coll]]}}, :info nil, :end-line 716, :tag any, :impls #{cljs.core/IndexedSeq cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet}, :doc "Protocol for reversing a seq.", :jsdoc ("@interface")}, reversible? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3146, :column 16, :end-line 3146, :end-column 27, :tag boolean, :arglists (quote ([coll])), :doc "Returns true if coll satisfies? IReversible."}, :name cljs.core/reversible?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3146, :ret-tag boolean, :end-line 3146, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([coll])), :doc "Returns true if coll satisfies? IReversible."}, -realized? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 756, :column 13, :end-line 756, :end-column 23, :tag boolean, :protocol cljs.core/IPending, :doc "Returns true if a value for x has been produced, false otherwise.", :arglists (quote ([x]))}, :protocol cljs.core/IPending, :name cljs.core/-realized?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 753, :ret-tag boolean, :end-line 756, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if a value for x has been produced, false otherwise."}, -add-watch {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 763, :column 4, :end-line 763, :end-column 14, :protocol cljs.core/IWatchable, :doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch.", :arglists (quote ([this key f]))}, :protocol cljs.core/IWatchable, :name cljs.core/-add-watch, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([this key f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 759, :end-line 763, :max-fixed-arity 3, :fn-var true, :arglists (quote ([this key f])), :doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch."}, -deref-with-timeout {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 665, :column 4, :end-line 665, :end-column 23, :protocol cljs.core/IDerefWithTimeout, :doc nil, :arglists (quote ([o msec timeout-val]))}, :protocol cljs.core/IDerefWithTimeout, :name cljs.core/-deref-with-timeout, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([o msec timeout-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 664, :end-line 665, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o msec timeout-val])), :doc nil}, conj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1761, :column 7, :end-line 1761, :end-column 11, :arglists (quote ([] [coll] [coll x] [coll x & xs])), :doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [coll] [coll x]), :arglists ([] [coll] [coll x] [coll x & xs]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/conj, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [coll] [coll x]), :arglists ([] [coll] [coll x] [coll x & xs]), :arglists-meta (nil nil nil nil)}, :method-params ([] [coll] [coll x]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 1761, :end-line 1761, :max-fixed-arity 2, :fn-var true, :arglists ([] [coll] [coll x] [coll x & xs]), :doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type."}, -sorted-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 724, :column 9, :end-line 724, :end-column 20, :tag clj, :protocol cljs.core/ISorted, :doc "Returns a sorted seq from coll in either ascending or descending order.", :arglists (quote ([coll ascending?]))}, :protocol cljs.core/ISorted, :name cljs.core/-sorted-seq, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([coll ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 721, :ret-tag clj, :end-line 724, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll ascending?])), :doc "Returns a sorted seq from coll in either ascending or descending order."}, flatten1 {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4820, :column 8, :end-line 4820, :end-column 16, :private true, :arglists (quote ([colls])), :doc "Take a collection of collections, and return a lazy seq\n  of items from the inner collection"}, :private true, :name cljs.core/flatten1, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4820, :end-line 4820, :max-fixed-arity 1, :fn-var true, :arglists (quote ([colls])), :doc "Take a collection of collections, and return a lazy seq\n  of items from the inner collection"}, transduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2548, :column 7, :end-line 2548, :end-column 16, :arglists (quote ([xform f coll] [xform f init coll])), :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([xform f coll] [xform f init coll]), :arglists ([xform f coll] [xform f init coll]), :arglists-meta (nil nil)}}, :name cljs.core/transduce, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([xform f coll] [xform f init coll]), :arglists ([xform f coll] [xform f init coll]), :arglists-meta (nil nil)}, :method-params ([xform f coll] [xform f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2548, :end-line 2548, :max-fixed-arity 4, :fn-var true, :arglists ([xform f coll] [xform f init coll]), :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items."}, fixture1 {:name cljs.core/fixture1, :file "cljs/core.cljs", :line 10053, :column 1, :end-line 10053, :end-column 14, :meta {:file "cljs/core.cljs", :line 10053, :column 6, :end-line 10053, :end-column 14}, :tag number}, -swap! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 844, :column 4, :end-line 844, :end-column 10, :protocol cljs.core/ISwap, :doc "Swaps the value of o to be (apply f current-value-of-atom args).", :arglists (quote ([o f] [o f a] [o f a b] [o f a b xs])), :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([o f] [o f a] [o f a b] [o f a b xs]), :arglists ([o f] [o f a] [o f a b] [o f a b xs]), :arglists-meta (nil nil nil nil)}}, :protocol cljs.core/ISwap, :name cljs.core/-swap!, :variadic false, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([o f] [o f a] [o f a b] [o f a b xs]), :arglists ([o f] [o f a] [o f a b] [o f a b xs]), :arglists-meta (nil nil nil nil)}, :method-params ([o f] [o f a] [o f a b] [o f a b xs]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 842, :end-line 844, :max-fixed-arity 5, :fn-var true, :arglists ([o f] [o f a] [o f a b] [o f a b xs]), :doc "Swaps the value of o to be (apply f current-value-of-atom args)."}, *print-length* {:meta {:file "cljs/core.cljs", :line 140, :column 3, :end-line 140, :end-column 17, :dynamic true, :doc "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit.", :jsdoc ["@type {null|number}"]}, :name cljs.core/*print-length*, :file "cljs/core.cljs", :end-column 17, :column 1, :dynamic true, :line 130, :end-line 140, :tag clj-nil, :doc "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit.", :jsdoc ["@type {null|number}"]}, js-delete {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2157, :column 7, :end-line 2157, :end-column 16, :arglists (quote ([obj key])), :doc "Delete a property from a JavaScript object."}, :name cljs.core/js-delete, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([obj key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2157, :end-line 2157, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj key])), :doc "Delete a property from a JavaScript object."}, truth_ {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 203, :column 7, :end-line 203, :end-column 13, :arglists (quote ([x])), :doc "Internal - do not use!"}, :name cljs.core/truth_, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 203, :end-line 203, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Internal - do not use!"}, array-index-of {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6273, :column 7, :end-line 6273, :end-column 21, :arglists (quote ([arr k]))}, :name cljs.core/array-index-of, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6273, :end-line 6273, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, ->MultiFn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10519, :column 10, :end-line 10519, :end-column 17, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :factory :positional, :arglists (quote ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]))}, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :name cljs.core/->MultiFn, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 10519, :end-line 10519, :max-fixed-arity 8, :fn-var true, :arglists (quote ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy])), :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}}, key->js {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10209, :column 7, :end-line 10209, :end-column 14, :arglists (quote ([k]))}, :name cljs.core/key->js, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10209, :end-line 10209, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, IEncodeJS {:meta {:file "cljs/core.cljs", :line 10202, :column 14, :end-line 10202, :end-column 23, :doc nil, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-clj->js [[x]], -key->js [[x]]}}}, :protocol-symbol true, :name cljs.core/IEncodeJS, :file "cljs/core.cljs", :end-column 23, :column 1, :line 10202, :protocol-info {:methods {-clj->js [[x]], -key->js [[x]]}}, :info nil, :end-line 10202, :tag any, :impls #{}, :doc nil, :jsdoc ("@interface")}, new-path {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5060, :column 8, :end-line 5060, :end-column 16, :private true, :arglists (quote ([edit level node]))}, :private true, :name cljs.core/new-path, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([edit level node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5060, :end-line 5060, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit level node]))}, compare-and-set! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4448, :column 7, :end-line 4448, :end-column 23, :arglists (quote ([a oldval newval])), :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false."}, :name cljs.core/compare-and-set!, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([a oldval newval]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4448, :end-line 4448, :max-fixed-arity 3, :fn-var true, :arglists (quote ([a oldval newval])), :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false."}, array-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1652, :column 7, :end-line 1652, :end-column 16, :arglists (quote ([array] [array i])), :doc "Create a seq from a JavaScript array.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([array] [array i]), :arglists ([array] [array i]), :arglists-meta (nil nil)}}, :name cljs.core/array-seq, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([array] [array i]), :arglists ([array] [array i]), :arglists-meta (nil nil)}, :method-params ([array] [array i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1652, :end-line 1652, :max-fixed-arity 2, :fn-var true, :arglists ([array] [array i]), :doc "Create a seq from a JavaScript array."}, array-copy-downward {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2170, :column 8, :end-line 2170, :end-column 27, :private true, :arglists (quote ([from i to j len]))}, :private true, :name cljs.core/array-copy-downward, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([from i to j len]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2170, :end-line 2170, :max-fixed-arity 5, :fn-var true, :arglists (quote ([from i to j len]))}, pack-array-node {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7078, :column 8, :end-line 7078, :end-column 23, :private true, :arglists (quote ([array-node edit idx]))}, :private true, :name cljs.core/pack-array-node, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([array-node edit idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7078, :end-line 7078, :max-fixed-arity 3, :fn-var true, :arglists (quote ([array-node edit idx]))}, interleave {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4782, :column 7, :end-line 4782, :end-column 17, :arglists (quote ([] [c1] [c1 c2] [c1 c2 & colls])), :doc "Returns a lazy seq of the first item in each coll, then the second etc.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [c1] [c1 c2]), :arglists ([] [c1] [c1 c2] [c1 c2 & colls]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/interleave, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [c1] [c1 c2]), :arglists ([] [c1] [c1 c2] [c1 c2 & colls]), :arglists-meta (nil nil nil nil)}, :method-params ([] [c1] [c1 c2]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 4782, :end-line 4782, :max-fixed-arity 2, :fn-var true, :arglists ([] [c1] [c1 c2] [c1 c2 & colls]), :doc "Returns a lazy seq of the first item in each coll, then the second etc."}, print-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9830, :column 7, :end-line 9830, :end-column 16, :arglists (quote ([m print-one writer opts]))}, :name cljs.core/print-map, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([m print-one writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9830, :end-line 9830, :max-fixed-arity 4, :fn-var true, :arglists (quote ([m print-one writer opts]))}, map? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2119, :column 16, :end-line 2119, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies IMap"}, :name cljs.core/map?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2119, :ret-tag boolean, :end-line 2119, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IMap"}, m3-C1 {:name cljs.core/m3-C1, :file "cljs/core.cljs", :line 899, :column 1, :end-line 899, :end-column 11, :meta {:file "cljs/core.cljs", :line 899, :column 6, :end-line 899, :end-column 11}, :tag number}, get {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1903, :column 7, :end-line 1903, :end-column 10, :arglists (quote ([o k] [o k not-found])), :doc "Returns the value mapped to key, not-found or nil if key not present.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([o k] [o k not-found]), :arglists ([o k] [o k not-found]), :arglists-meta (nil nil)}}, :name cljs.core/get, :variadic false, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([o k] [o k not-found]), :arglists ([o k] [o k not-found]), :arglists-meta (nil nil)}, :method-params ([o k] [o k not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1903, :end-line 1903, :max-fixed-arity 3, :fn-var true, :arglists ([o k] [o k not-found]), :doc "Returns the value mapped to key, not-found or nil if key not present."}, identity {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2533, :column 7, :end-line 2533, :end-column 15, :arglists (quote ([x])), :doc "Returns its argument."}, :name cljs.core/identity, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2533, :end-line 2533, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns its argument."}, into {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4904, :column 7, :end-line 4904, :end-column 11, :arglists (quote ([] [to] [to from] [to xform from])), :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([] [to] [to from] [to xform from]), :arglists ([] [to] [to from] [to xform from]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/into, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([] [to] [to from] [to xform from]), :arglists ([] [to] [to from] [to xform from]), :arglists-meta (nil nil nil nil)}, :method-params ([] [to] [to from] [to xform from]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 4904, :end-line 4904, :max-fixed-arity 3, :fn-var true, :arglists ([] [to] [to from] [to xform from]), :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied."}, ->t_cljs$core14407 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([meta14408])), :file "cljs/core.cljs"}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t_cljs$core14407, :variadic false, :file "cljs/core.cljs", :method-params ([meta14408]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :line 3948, :max-fixed-arity 1, :fn-var true, :arglists (quote ([meta14408])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, long {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2774, :column 7, :end-line 2774, :end-column 11, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, :name cljs.core/long, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2774, :end-line 2774, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, double {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2675, :column 15, :end-line 2675, :end-column 21, :tag number, :arglists (quote ([x]))}, :name cljs.core/double, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2675, :ret-tag number, :end-line 2675, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, volatile? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4488, :column 16, :end-line 4488, :end-column 25, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a volatile."}, :name cljs.core/volatile?, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4488, :ret-tag boolean, :end-line 4488, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a volatile."}, ChunkBuffer {:num-fields 2, :protocols #{cljs.core/Object cljs.core/ICounted}, :name cljs.core/ChunkBuffer, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 3451, :record false, :end-line 3451, :skip-protocol-flag #{cljs.core/ICounted}}, HashSetIter {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/HashSetIter, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 8745, :record false, :end-line 8745, :skip-protocol-flag nil}, -key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 634, :column 4, :end-line 634, :end-column 8, :protocol cljs.core/IMapEntry, :doc "Returns the key of the map entry.", :arglists (quote ([coll]))}, :protocol cljs.core/IMapEntry, :name cljs.core/-key, :variadic false, :file "cljs/core.cljs", :end-column 8, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 632, :end-line 634, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the key of the map entry."}, nfirst {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1734, :column 7, :end-line 1734, :end-column 13, :arglists (quote ([coll])), :doc "Same as (next (first x))"}, :name cljs.core/nfirst, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1734, :end-line 1734, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (next (first x))"}, StringBufferWriter {:num-fields 1, :protocols #{cljs.core/IWriter}, :name cljs.core/StringBufferWriter, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 860, :record false, :end-line 860, :skip-protocol-flag #{cljs.core/IWriter}}, meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2043, :column 7, :end-line 2043, :end-column 11, :arglists (quote ([o])), :doc "Returns the metadata of obj, returns nil if there is no metadata."}, :name cljs.core/meta, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2043, :end-line 2043, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the metadata of obj, returns nil if there is no metadata."}, tv-editable-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5677, :column 8, :end-line 5677, :end-column 24, :private true, :arglists (quote ([tl]))}, :private true, :name cljs.core/tv-editable-tail, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([tl]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5677, :end-line 5677, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tl]))}, -kv-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 688, :column 4, :end-line 688, :end-column 14, :protocol cljs.core/IKVReduce, :doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments.", :arglists (quote ([coll f init]))}, :protocol cljs.core/IKVReduce, :name cljs.core/-kv-reduce, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 685, :end-line 688, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll f init])), :doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments."}, IHash {:meta {:file "cljs/core.cljs", :line 697, :column 14, :end-line 697, :end-column 19, :doc "Protocol for adding hashing functionality to a type.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-hash [[o]]}}}, :protocol-symbol true, :name cljs.core/IHash, :file "cljs/core.cljs", :end-column 19, :column 1, :line 697, :protocol-info {:methods {-hash [[o]]}}, :info nil, :end-line 697, :tag any, :impls #{cljs.core/Namespace cljs.core/PersistentHashMap cljs.core/MultiFn cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Keyword cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/TaggedLiteral default cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding hashing functionality to a type.", :jsdoc ("@interface")}, bit-and-not {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2833, :column 7, :end-line 2833, :end-column 18, :arglists (quote ([x y] [x y & more])), :doc "Bitwise and with complement", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}}, :name cljs.core/bit-and-not, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2833, :end-line 2833, :max-fixed-arity 2, :fn-var true, :arglists ([x y] [x y & more]), :doc "Bitwise and with complement"}, var? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1166, :column 16, :end-line 1166, :end-column 20, :tag boolean, :arglists (quote ([v])), :doc "Returns true if v is of type cljs.core.Var"}, :name cljs.core/var?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1166, :ret-tag boolean, :end-line 1166, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([v])), :doc "Returns true if v is of type cljs.core.Var"}, -comparator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 735, :column 4, :end-line 735, :end-column 15, :protocol cljs.core/ISorted, :doc "Returns the comparator for coll.", :arglists (quote ([coll]))}, :protocol cljs.core/ISorted, :name cljs.core/-comparator, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 721, :end-line 735, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the comparator for coll."}, unchecked-add-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2690, :column 15, :end-line 2690, :end-column 32, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/unchecked-add-int, :variadic true, :file "cljs/core.cljs", :end-column 32, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 2690, :ret-tag number, :end-line 2690, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the sum of nums. (+) returns 0."}, hash-ordered-coll {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1313, :column 15, :end-line 1313, :end-column 32, :tag number, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms."}, :name cljs.core/hash-ordered-coll, :variadic false, :file "cljs/core.cljs", :end-column 32, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1313, :ret-tag number, :end-line 1313, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms."}, extend-object! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2992, :column 8, :end-line 2992, :end-column 22, :private true, :arglists (quote ([obj fn-map])), :doc "Takes a JavaScript object and a map of names to functions and\n  attaches said functions as methods on the object.  Any references to\n  JavaScript's implicit this (via the this-as macro) will resolve to the\n  object that the function is attached."}, :private true, :name cljs.core/extend-object!, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([obj fn-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2992, :end-line 2992, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj fn-map])), :doc "Takes a JavaScript object and a map of names to functions and\n  attaches said functions as methods on the object.  Any references to\n  JavaScript's implicit this (via the this-as macro) will resolve to the\n  object that the function is attached."}, do-assoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5113, :column 8, :end-line 5113, :end-column 16, :private true, :arglists (quote ([pv level node i val]))}, :private true, :name cljs.core/do-assoc, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([pv level node i val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5113, :end-line 5113, :max-fixed-arity 5, :fn-var true, :arglists (quote ([pv level node i val]))}, reset-meta! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10001, :column 7, :end-line 10001, :end-column 18, :arglists (quote ([iref m])), :doc "Atomically resets the metadata for an atom"}, :name cljs.core/reset-meta!, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([iref m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10001, :end-line 10001, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref m])), :doc "Atomically resets the metadata for an atom"}, ->KeySeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8551, :column 10, :end-line 8551, :end-column 16, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([mseq _meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->KeySeq, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([mseq _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 8551, :end-line 8551, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mseq _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, IEquiv {:meta {:file "cljs/core.cljs", :line 692, :column 14, :end-line 692, :end-column 20, :doc "Protocol for adding value comparison functionality to a type.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-equiv [[o other]]}}}, :protocol-symbol true, :name cljs.core/IEquiv, :file "cljs/core.cljs", :end-column 20, :column 1, :line 692, :protocol-info {:methods {-equiv [[o other]]}}, :info nil, :end-line 692, :tag any, :impls #{cljs.core/Namespace cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq js/Date cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Keyword cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/TaggedLiteral number default cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/NeverEquiv cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding value comparison functionality to a type.", :jsdoc ("@interface")}, tree-map-kv-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7944, :column 8, :end-line 7944, :end-column 26, :private true, :arglists (quote ([node f init]))}, :private true, :name cljs.core/tree-map-kv-reduce, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([node f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7944, :end-line 7944, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node f init]))}, cycle {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4749, :column 7, :end-line 4749, :end-column 12, :arglists (quote ([coll])), :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll."}, :name cljs.core/cycle, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4749, :end-line 4749, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll."}, -deref {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 661, :column 4, :end-line 661, :end-column 10, :protocol cljs.core/IDeref, :doc "Returns the value of the reference o.", :arglists (quote ([o]))}, :protocol cljs.core/IDeref, :name cljs.core/-deref, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 659, :end-line 661, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the value of the reference o."}, pr-writer-ex-info {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10792, :column 8, :end-line 10792, :end-column 25, :private true, :arglists (quote ([obj writer opts]))}, :private true, :name cljs.core/pr-writer-ex-info, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([obj writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10792, :end-line 10792, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts]))}, empty? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2079, :column 16, :end-line 2079, :end-column 22, :tag boolean, :arglists (quote ([coll])), :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))"}, :name cljs.core/empty?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2079, :ret-tag boolean, :end-line 2079, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([coll])), :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))"}, TaggedLiteral {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/ILookup}, :name cljs.core/TaggedLiteral, :file "cljs/core.cljs", :end-column 23, :type true, :column 10, :line 10885, :record false, :end-line 10885, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/ILookup}}, short {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2673, :column 15, :end-line 2673, :end-column 20, :tag number, :arglists (quote ([x]))}, :name cljs.core/short, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2673, :ret-tag number, :end-line 2673, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, -clj->js {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10203, :column 4, :end-line 10203, :end-column 12, :protocol cljs.core/IEncodeJS, :doc "Recursively transforms clj values to JavaScript", :arglists (quote ([x]))}, :protocol cljs.core/IEncodeJS, :name cljs.core/-clj->js, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10202, :end-line 10203, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Recursively transforms clj values to JavaScript"}, -chunked-first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 817, :column 4, :end-line 817, :end-column 18, :protocol cljs.core/IChunkedSeq, :doc "Returns the first chunk in coll.", :arglists (quote ([coll]))}, :protocol cljs.core/IChunkedSeq, :name cljs.core/-chunked-first, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 815, :end-line 817, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the first chunk in coll."}, filterv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4936, :column 7, :end-line 4936, :end-column 14, :arglists (quote ([pred coll])), :doc "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects."}, :name cljs.core/filterv, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4936, :end-line 4936, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects."}, ->TaggedLiteral {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10885, :column 10, :end-line 10885, :end-column 23, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/ILookup}, :factory :positional, :arglists (quote ([tag form]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/ILookup}, :name cljs.core/->TaggedLiteral, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([tag form]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 10885, :end-line 10885, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag form])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/ILookup}}, tv-editable-root {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5674, :column 8, :end-line 5674, :end-column 24, :private true, :arglists (quote ([node]))}, :private true, :name cljs.core/tv-editable-root, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5674, :end-line 5674, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, hash {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 975, :column 7, :end-line 975, :end-column 11, :arglists (quote ([o])), :doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =."}, :name cljs.core/hash, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 975, :end-line 975, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =."}, quot {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2803, :column 7, :end-line 2803, :end-column 11, :arglists (quote ([n d])), :doc "quot[ient] of dividing numerator by denominator."}, :name cljs.core/quot, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2803, :end-line 2803, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "quot[ient] of dividing numerator by denominator."}, ns-interns* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11082, :column 7, :end-line 11082, :end-column 18, :arglists (quote ([sym])), :doc "Returns a map of the intern mappings for the namespace.\n  Bootstrap only."}, :name cljs.core/ns-interns*, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 11082, :end-line 11082, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym])), :doc "Returns a map of the intern mappings for the namespace.\n  Bootstrap only."}, unchecked-double {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2681, :column 15, :end-line 2681, :end-column 31, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-double, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2681, :ret-tag number, :end-line 2681, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, *target* {:meta {:file "cljs/core.cljs", :line 47, :column 3, :end-line 47, :end-column 11, :dynamic true, :doc "Var bound to the name value of the compiler build :target option.\n  For example, if the compiler build :target is :nodejs, *target* will be bound\n  to \"nodejs\". *target* is a Google Closure define and can be set by compiler\n  :closure-defines option.", :declared true}, :name cljs.core/*target*, :file "cljs/core.cljs", :end-column 11, :column 1, :dynamic true, :line 41, :declared true, :end-line 47, :doc "Var bound to the name value of the compiler build :target option.\n  For example, if the compiler build :target is :nodejs, *target* will be bound\n  to \"nodejs\". *target* is a Google Closure define and can be set by compiler\n  :closure-defines option."}, ->ChunkedCons {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3500, :column 10, :end-line 3500, :end-column 21, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([chunk more meta __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->ChunkedCons, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([chunk more meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3500, :end-line 3500, :max-fixed-arity 4, :fn-var true, :arglists (quote ([chunk more meta __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}}, ranged-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5149, :column 7, :end-line 5149, :end-column 22, :arglists (quote ([v start end]))}, :name cljs.core/ranged-iterator, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5149, :end-line 5149, :max-fixed-arity 3, :fn-var true, :arglists (quote ([v start end]))}, ITransientVector {:meta {:file "cljs/core.cljs", :line 792, :column 14, :end-line 792, :end-column 30, :doc "Protocol for adding vector functionality to transient collections.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-assoc-n! [[tcoll n val]], -pop! [[tcoll]]}}}, :protocol-symbol true, :name cljs.core/ITransientVector, :file "cljs/core.cljs", :end-column 30, :column 1, :line 792, :protocol-info {:methods {-assoc-n! [[tcoll n val]], -pop! [[tcoll]]}}, :info nil, :end-line 792, :tag any, :impls #{cljs.core/TransientVector}, :doc "Protocol for adding vector functionality to transient collections.", :jsdoc ("@interface")}, key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8622, :column 7, :end-line 8622, :end-column 10, :arglists (quote ([map-entry])), :doc "Returns the key of the map entry."}, :name cljs.core/key, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([map-entry]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8622, :end-line 8622, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-entry])), :doc "Returns the key of the map entry."}, longs {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2791, :column 7, :end-line 2791, :end-column 12, :arglists (quote ([x]))}, :name cljs.core/longs, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2791, :end-line 2791, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, not= {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3936, :column 16, :end-line 3936, :end-column 20, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Same as (not (= obj1 obj2))", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/not=, :variadic true, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 3936, :ret-tag boolean, :end-line 3936, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Same as (not (= obj1 obj2))"}, set-print-err-fn! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 80, :column 7, :end-line 80, :end-column 24, :arglists (quote ([f])), :doc "Set *print-err-fn* to f."}, :name cljs.core/set-print-err-fn!, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 80, :end-line 80, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Set *print-err-fn* to f."}, string? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 253, :column 16, :end-line 253, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript string."}, :name cljs.core/string?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 253, :ret-tag boolean, :end-line 253, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript string."}, es6-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1274, :column 7, :end-line 1274, :end-column 19, :arglists (quote ([coll])), :doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll."}, :name cljs.core/es6-iterator, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1274, :end-line 1274, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll."}, Delay {:num-fields 2, :protocols #{cljs.core/IPending cljs.core/IDeref}, :name cljs.core/Delay, :file "cljs/core.cljs", :end-column 15, :type true, :column 10, :line 10058, :record false, :end-line 10058, :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref}}, munge-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10972, :column 8, :end-line 10972, :end-column 17, :private true, :arglists (quote ([name]))}, :private true, :name cljs.core/munge-str, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10972, :end-line 10972, :max-fixed-arity 1, :fn-var true, :arglists (quote ([name]))}, pr-str-with-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9718, :column 7, :end-line 9718, :end-column 23, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects to a string, observing all the\n  options given in opts"}, :name cljs.core/pr-str-with-opts, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9718, :end-line 9718, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects to a string, observing all the\n  options given in opts"}, ->RecordIter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6189, :column 10, :end-line 6189, :end-column 20, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([i record base-count fields ext-map-iter]))}, :protocols #{cljs.core/Object}, :name cljs.core/->RecordIter, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([i record base-count fields ext-map-iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6189, :end-line 6189, :max-fixed-arity 5, :fn-var true, :arglists (quote ([i record base-count fields ext-map-iter])), :skip-protocol-flag nil}, m3-C2 {:name cljs.core/m3-C2, :file "cljs/core.cljs", :line 900, :column 1, :end-line 900, :end-column 11, :meta {:file "cljs/core.cljs", :line 900, :column 6, :end-line 900, :end-column 11}, :tag number}, ->Symbol {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1048, :column 10, :end-line 1048, :end-column 16, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([ns name str _hash _meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :name cljs.core/->Symbol, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([ns name str _hash _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1048, :end-line 1048, :max-fixed-arity 5, :fn-var true, :arglists (quote ([ns name str _hash _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}}, *print-newline* {:meta {:file "cljs/core.cljs", :line 96, :column 3, :end-line 96, :end-column 18, :dynamic true, :doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects."}, :name cljs.core/*print-newline*, :file "cljs/core.cljs", :end-column 18, :column 1, :dynamic true, :line 91, :end-line 96, :tag boolean, :doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects."}, unchecked-multiply-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2727, :column 15, :end-line 2727, :end-column 37, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/unchecked-multiply-int, :variadic true, :file "cljs/core.cljs", :end-column 37, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 2727, :ret-tag number, :end-line 2727, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the product of nums. (*) returns 1."}, chunk-rest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3586, :column 7, :end-line 3586, :end-column 17, :arglists (quote ([s]))}, :name cljs.core/chunk-rest, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3586, :end-line 3586, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, remove-all-methods {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10704, :column 7, :end-line 10704, :end-column 25, :arglists (quote ([multifn])), :doc "Removes all of the methods of multimethod."}, :name cljs.core/remove-all-methods, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10704, :end-line 10704, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Removes all of the methods of multimethod."}, trampoline {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10288, :column 7, :end-line 10288, :end-column 17, :arglists (quote ([f] [f & args])), :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([f]), :arglists ([f] [f & args]), :arglists-meta (nil nil)}}, :name cljs.core/trampoline, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([f]), :arglists ([f] [f & args]), :arglists-meta (nil nil)}, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10288, :end-line 10288, :max-fixed-arity 1, :fn-var true, :arglists ([f] [f & args]), :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns."}, double? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2293, :column 16, :end-line 2293, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Returns true for JavaScript numbers, false otherwise."}, :name cljs.core/double?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2293, :ret-tag boolean, :end-line 2293, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true for JavaScript numbers, false otherwise."}, pr-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 166, :column 8, :end-line 166, :end-column 15, :private true, :arglists (quote ([]))}, :private true, :name cljs.core/pr-opts, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 166, :end-line 166, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, *1 {:name cljs.core/*1, :file "cljs/core.cljs", :line 187, :column 1, :end-line 189, :end-column 5, :doc "bound in a repl thread to the most recent value printed", :meta {:file "cljs/core.cljs", :line 189, :column 3, :end-line 189, :end-column 5, :doc "bound in a repl thread to the most recent value printed"}}, vec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5398, :column 7, :end-line 5398, :end-column 10, :arglists (quote ([coll])), :doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified."}, :name cljs.core/vec, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5398, :end-line 5398, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified."}, *print-meta* {:meta {:file "cljs/core.cljs", :line 112, :column 3, :end-line 112, :end-column 15, :dynamic true, :doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false."}, :name cljs.core/*print-meta*, :file "cljs/core.cljs", :end-column 15, :column 1, :dynamic true, :line 106, :end-line 112, :tag boolean, :doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false."}, -notify-watches {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 761, :column 4, :end-line 761, :end-column 19, :protocol cljs.core/IWatchable, :doc "Calls all watchers with this, oldval and newval.", :arglists (quote ([this oldval newval]))}, :protocol cljs.core/IWatchable, :name cljs.core/-notify-watches, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([this oldval newval]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 759, :end-line 761, :max-fixed-arity 3, :fn-var true, :arglists (quote ([this oldval newval])), :doc "Calls all watchers with this, oldval and newval."}, MultiFn {:num-fields 8, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :name cljs.core/MultiFn, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 10519, :record false, :end-line 10519, :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}}, NONE {:name cljs.core/NONE, :file "cljs/core.cljs", :line 4023, :column 1, :end-line 4023, :end-column 20, :private true, :meta {:file "cljs/core.cljs", :line 4023, :column 16, :end-line 4023, :end-column 20, :private true}, :tag object}, int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2764, :column 7, :end-line 2764, :end-column 10, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, :name cljs.core/int, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2764, :end-line 2764, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, ->ValSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8627, :column 10, :end-line 8627, :end-column 16, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([mseq _meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ValSeq, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([mseq _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 8627, :end-line 8627, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mseq _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, rand {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10304, :column 7, :end-line 10304, :end-column 11, :arglists (quote ([] [n])), :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [n]), :arglists ([] [n]), :arglists-meta (nil nil)}}, :name cljs.core/rand, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [n]), :arglists ([] [n]), :arglists-meta (nil nil)}, :method-params ([] [n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10304, :end-line 10304, :max-fixed-arity 1, :fn-var true, :arglists ([] [n]), :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive)."}, second {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1724, :column 7, :end-line 1724, :end-column 13, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, :name cljs.core/second, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1724, :end-line 1724, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, find-ns-obj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11059, :column 7, :end-line 11059, :end-column 18, :arglists (quote ([ns])), :doc "Bootstrap only."}, :name cljs.core/find-ns-obj, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([ns]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 11059, :end-line 11059, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ns])), :doc "Bootstrap only."}, IEditableCollection {:meta {:file "cljs/core.cljs", :line 769, :column 14, :end-line 769, :end-column 33, :doc "Protocol for collections which can transformed to transients.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-as-transient [[coll]]}}}, :protocol-symbol true, :name cljs.core/IEditableCollection, :file "cljs/core.cljs", :end-column 33, :column 1, :line 769, :protocol-info {:methods {-as-transient [[coll]]}}, :info nil, :end-line 769, :tag any, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/PersistentVector cljs.core/PersistentHashSet}, :doc "Protocol for collections which can transformed to transients.", :jsdoc ("@interface")}, hash-combine {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1011, :column 7, :end-line 1011, :end-column 19, :arglists (quote ([seed hash]))}, :name cljs.core/hash-combine, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([seed hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1011, :end-line 1011, :max-fixed-arity 2, :fn-var true, :arglists (quote ([seed hash]))}, > {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2621, :column 16, :end-line 2621, :end-column 17, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/>, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2621, :ret-tag boolean, :end-line 2621, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false."}, -name {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 829, :column 12, :end-line 829, :end-column 17, :tag string, :protocol cljs.core/INamed, :doc "Returns the name String of x.", :arglists (quote ([x]))}, :protocol cljs.core/INamed, :name cljs.core/-name, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 827, :ret-tag string, :end-line 829, :max-fixed-arity 1, :tag string, :fn-var true, :arglists (quote ([x])), :doc "Returns the name String of x."}, replace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9046, :column 7, :end-line 9046, :end-column 14, :arglists (quote ([smap] [smap coll])), :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([smap] [smap coll]), :arglists ([smap] [smap coll]), :arglists-meta (nil nil)}}, :name cljs.core/replace, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([smap] [smap coll]), :arglists ([smap] [smap coll]), :arglists-meta (nil nil)}, :method-params ([smap] [smap coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9046, :end-line 9046, :max-fixed-arity 2, :fn-var true, :arglists ([smap] [smap coll]), :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided."}, int? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2235, :column 16, :end-line 2235, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies integer? or is an instance of goog.math.Integer\n   or goog.math.Long."}, :name cljs.core/int?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2235, :ret-tag boolean, :end-line 2235, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies integer? or is an instance of goog.math.Integer\n   or goog.math.Long."}, ->Subvec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5510, :column 10, :end-line 5510, :end-column 16, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta v start end __hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->Subvec, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([meta v start end __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5510, :end-line 5510, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta v start end __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, associative? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2099, :column 16, :end-line 2099, :end-column 28, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll implements Associative"}, :name cljs.core/associative?, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2099, :ret-tag boolean, :end-line 2099, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements Associative"}, unchecked-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2769, :column 7, :end-line 2769, :end-column 20, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, :name cljs.core/unchecked-int, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2769, :end-line 2769, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, js-keys {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2150, :column 7, :end-line 2150, :end-column 14, :arglists (quote ([obj])), :doc "Return the JavaScript keys for an object."}, :name cljs.core/js-keys, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2150, :end-line 2150, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj])), :doc "Return the JavaScript keys for an object."}, inst-ms* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1366, :column 4, :end-line 1366, :end-column 12, :protocol cljs.core/Inst, :doc nil, :arglists (quote ([inst]))}, :protocol cljs.core/Inst, :name cljs.core/inst-ms*, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([inst]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1365, :end-line 1366, :max-fixed-arity 1, :fn-var true, :arglists (quote ([inst])), :doc nil}, ES6EntriesIterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6EntriesIterator, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 6202, :record false, :end-line 6202, :skip-protocol-flag nil}, keyword? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3289, :column 16, :end-line 3289, :end-column 24, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a Keyword"}, :name cljs.core/keyword?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3289, :ret-tag boolean, :end-line 3289, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a Keyword"}, array-iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3975, :column 7, :end-line 3975, :end-column 17, :arglists (quote ([x]))}, :name cljs.core/array-iter, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3975, :end-line 3975, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, force {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10074, :column 7, :end-line 10074, :end-column 12, :arglists (quote ([x])), :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"}, :name cljs.core/force, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10074, :end-line 10074, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"}, group-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10321, :column 7, :end-line 10321, :end-column 15, :arglists (quote ([f coll])), :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll."}, :name cljs.core/group-by, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10321, :end-line 10321, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f coll])), :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll."}, -rseq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 718, :column 9, :end-line 718, :end-column 14, :tag clj, :protocol cljs.core/IReversible, :doc "Returns a seq of the items in coll in reversed order.", :arglists (quote ([coll]))}, :protocol cljs.core/IReversible, :name cljs.core/-rseq, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 716, :ret-tag clj, :end-line 718, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reversed order."}, prn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9791, :column 7, :end-line 9791, :end-column 10, :arglists (quote ([& objs])), :doc "Same as pr followed by (newline).", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/prn, :variadic true, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9791, :end-line 9791, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "Same as pr followed by (newline)."}, tv-pop-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5694, :column 8, :end-line 5694, :end-column 19, :private true, :arglists (quote ([tv level node]))}, :private true, :name cljs.core/tv-pop-tail, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([tv level node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5694, :end-line 5694, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tv level node]))}, default-dispatch-val {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10733, :column 7, :end-line 10733, :end-column 27, :arglists (quote ([multifn])), :doc "Given a multimethod, return it's default-dispatch-val."}, :name cljs.core/default-dispatch-val, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10733, :end-line 10733, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, return it's default-dispatch-val."}, ->Atom {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4362, :column 10, :end-line 4362, :end-column 14, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}, :factory :positional, :arglists (quote ([state meta validator watches]))}, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/->Atom, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([state meta validator watches]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 4362, :end-line 4362, :max-fixed-arity 4, :fn-var true, :arglists (quote ([state meta validator watches])), :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}}, PersistentHashMap {:meta {:file "cljs/core.cljs", :line 1945, :column 10, :end-line 1945, :end-column 27, :declared true}, :num-fields 6, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/PersistentHashMap, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7498, :record false, :declared true, :end-line 7498, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, unchecked-multiply {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2720, :column 15, :end-line 2720, :end-column 33, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/unchecked-multiply, :variadic true, :file "cljs/core.cljs", :end-column 33, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 2720, :ret-tag number, :end-line 2720, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the product of nums. (*) returns 1."}, ArrayNodeSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ArrayNodeSeq, :file "cljs/core.cljs", :end-column 22, :type true, :column 10, :line 7419, :record false, :end-line 7419, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, even? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4193, :column 16, :end-line 4193, :end-column 21, :tag boolean, :arglists (quote ([n])), :doc "Returns true if n is even, throws an exception if n is not an integer"}, :name cljs.core/even?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4193, :ret-tag boolean, :end-line 4193, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is even, throws an exception if n is not an integer"}, es6-iterator-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1291, :column 7, :end-line 1291, :end-column 23, :arglists (quote ([iter])), :doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq."}, :name cljs.core/es6-iterator-seq, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1291, :end-line 1291, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iter])), :doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq."}, unchecked-dec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2697, :column 7, :end-line 2697, :end-column 20, :arglists (quote ([x])), :doc "Returns a number one less than x, an int."}, :name cljs.core/unchecked-dec, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2697, :end-line 2697, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one less than x, an int."}, Inst {:meta {:file "cljs/core.cljs", :line 1365, :column 14, :end-line 1365, :end-column 18, :doc nil, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {inst-ms* [[inst]]}}}, :protocol-symbol true, :name cljs.core/Inst, :file "cljs/core.cljs", :end-column 18, :column 1, :line 1365, :protocol-info {:methods {inst-ms* [[inst]]}}, :info nil, :end-line 1365, :tag any, :impls #{js/Date}, :doc nil, :jsdoc ("@interface")}, hash-collision-node-find-index {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7212, :column 8, :end-line 7212, :end-column 38, :private true, :arglists (quote ([arr cnt key]))}, :private true, :name cljs.core/hash-collision-node-find-index, :variadic false, :file "cljs/core.cljs", :end-column 38, :method-params ([arr cnt key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7212, :end-line 7212, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr cnt key]))}, persistent-array-map-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6461, :column 7, :end-line 6461, :end-column 31, :arglists (quote ([arr i _meta]))}, :name cljs.core/persistent-array-map-seq, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([arr i _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6461, :end-line 6461, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i _meta]))}, RangeIterator {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/RangeIterator, :file "cljs/core.cljs", :end-column 23, :type true, :column 10, :line 9229, :record false, :end-line 9229, :skip-protocol-flag nil}, tagged-literal? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10915, :column 16, :end-line 10915, :end-column 31, :tag boolean, :arglists (quote ([value])), :doc "Return true if the value is the data representation of a tagged literal"}, :name cljs.core/tagged-literal?, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10915, :ret-tag boolean, :end-line 10915, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([value])), :doc "Return true if the value is the data representation of a tagged literal"}, double-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3661, :column 7, :end-line 3661, :end-column 19, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}}, :name cljs.core/double-array, :variadic false, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3661, :end-line 3661, :max-fixed-arity 2, :fn-var true, :arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure."}, ->t_cljs$core8963 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([meta8964])), :file "cljs/core.cljs"}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t_cljs$core8963, :variadic false, :file "cljs/core.cljs", :method-params ([meta8964]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :line 3948, :max-fixed-arity 1, :fn-var true, :arglists (quote ([meta8964])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, create-ns {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11095, :column 7, :end-line 11095, :end-column 16, :arglists (quote ([sym] [sym ns-obj])), :doc "Create a new namespace named by the symbol. Bootstrap only.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([sym] [sym ns-obj]), :arglists ([sym] [sym ns-obj]), :arglists-meta (nil nil)}}, :name cljs.core/create-ns, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([sym] [sym ns-obj]), :arglists ([sym] [sym ns-obj]), :arglists-meta (nil nil)}, :method-params ([sym] [sym ns-obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 11095, :end-line 11095, :max-fixed-arity 2, :fn-var true, :arglists ([sym] [sym ns-obj]), :doc "Create a new namespace named by the symbol. Bootstrap only."}, ->EmptyList {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3078, :column 10, :end-line 3078, :end-column 19, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta]))}, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->EmptyList, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3078, :end-line 3078, :max-fixed-arity 1, :fn-var true, :arglists (quote ([meta])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, seq-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2426, :column 8, :end-line 2426, :end-column 18, :private true, :arglists (quote ([f coll] [f val coll])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f val coll]), :arglists ([f coll] [f val coll]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/seq-reduce, :variadic false, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f val coll]), :arglists ([f coll] [f val coll]), :arglists-meta (nil nil)}, :method-params ([f coll] [f val coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2426, :end-line 2426, :max-fixed-arity 3, :fn-var true, :arglists ([f coll] [f val coll])}, spread {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3717, :column 7, :end-line 3717, :end-column 13, :arglists (quote ([arglist]))}, :name cljs.core/spread, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([arglist]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3717, :end-line 3717, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arglist]))}, balance-left {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7859, :column 8, :end-line 7859, :end-column 20, :private true, :arglists (quote ([key val ins right]))}, :private true, :name cljs.core/balance-left, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([key val ins right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7859, :end-line 7859, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val ins right]))}, rseq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3151, :column 12, :end-line 3151, :end-column 16, :tag seq, :arglists (quote ([rev])), :doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil"}, :name cljs.core/rseq, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([rev]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3151, :ret-tag seq, :end-line 3151, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([rev])), :doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil"}, ex-cause {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10853, :column 7, :end-line 10853, :end-column 15, :arglists (quote ([ex])), :doc "Returns exception cause (an Error / ExceptionInfo) if ex is an\n  ExceptionInfo.\n  Otherwise returns nil."}, :name cljs.core/ex-cause, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10853, :end-line 10853, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Returns exception cause (an Error / ExceptionInfo) if ex is an\n  ExceptionInfo.\n  Otherwise returns nil."}, IReset {:meta {:file "cljs/core.cljs", :line 837, :column 14, :end-line 837, :end-column 20, :doc "Protocol for adding resetting functionality.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-reset! [[o new-value]]}}}, :protocol-symbol true, :name cljs.core/IReset, :file "cljs/core.cljs", :end-column 20, :column 1, :line 837, :protocol-info {:methods {-reset! [[o new-value]]}}, :info nil, :end-line 837, :tag any, :impls #{}, :doc "Protocol for adding resetting functionality.", :jsdoc ("@interface")}, IEmptyableCollection {:meta {:file "cljs/core.cljs", :line 563, :column 14, :end-line 563, :end-column 34, :doc "Protocol for creating an empty collection.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-empty [[coll]]}}}, :protocol-symbol true, :name cljs.core/IEmptyableCollection, :file "cljs/core.cljs", :end-column 34, :column 1, :line 563, :protocol-info {:methods {-empty [[coll]]}}, :info nil, :end-line 563, :tag any, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for creating an empty collection.", :jsdoc ("@interface")}, array-map-index-of {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6287, :column 8, :end-line 6287, :end-column 26, :private true, :arglists (quote ([m k]))}, :private true, :name cljs.core/array-map-index-of, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6287, :end-line 6287, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m k]))}, ex-message {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10846, :column 7, :end-line 10846, :end-column 17, :arglists (quote ([ex])), :doc "Returns the message attached to the given Error / ExceptionInfo object.\n  For non-Errors returns nil."}, :name cljs.core/ex-message, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10846, :end-line 10846, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Returns the message attached to the given Error / ExceptionInfo object.\n  For non-Errors returns nil."}, ->NodeIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6838, :column 11, :end-line 6838, :end-column 23, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([arr i next-entry next-iter]))}, :protocols #{cljs.core/Object}, :name cljs.core/->NodeIterator, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([arr i next-entry next-iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 2, :factory :positional, :line 6838, :end-line 6838, :max-fixed-arity 4, :fn-var true, :arglists (quote ([arr i next-entry next-iter])), :skip-protocol-flag nil}, *print-fn-bodies* {:meta {:file "cljs/core.cljs", :line 159, :column 3, :end-line 159, :end-column 20, :dynamic true, :doc "*print-fns-bodies* controls whether functions print their source or\n    only their names."}, :name cljs.core/*print-fn-bodies*, :file "cljs/core.cljs", :end-column 20, :column 1, :dynamic true, :line 155, :end-line 159, :tag boolean, :doc "*print-fns-bodies* controls whether functions print their source or\n    only their names."}, string-print {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9581, :column 7, :end-line 9581, :end-column 19, :arglists (quote ([x]))}, :name cljs.core/string-print, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9581, :end-line 9581, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, float {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2674, :column 15, :end-line 2674, :end-column 20, :tag number, :arglists (quote ([x]))}, :name cljs.core/float, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2674, :ret-tag number, :end-line 2674, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, fixture2 {:name cljs.core/fixture2, :file "cljs/core.cljs", :line 10054, :column 1, :end-line 10054, :end-column 14, :meta {:file "cljs/core.cljs", :line 10054, :column 6, :end-line 10054, :end-column 14}, :tag number}, IRecord {:meta {:file "cljs/core.cljs", :line 713, :column 14, :end-line 713, :end-column 21, :doc "Marker interface indicating a record object", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/IRecord, :file "cljs/core.cljs", :end-column 21, :column 1, :line 713, :protocol-info {:methods {}}, :info nil, :end-line 713, :tag any, :impls #{}, :doc "Marker interface indicating a record object", :jsdoc ("@interface")}, pr-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9749, :column 7, :end-line 9749, :end-column 13, :arglists (quote ([& objs])), :doc "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/pr-str, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9749, :end-line 9749, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter."}, first-array-for-longvec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5089, :column 8, :end-line 5089, :end-column 31, :private true, :arglists (quote ([pv]))}, :private true, :name cljs.core/first-array-for-longvec, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([pv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5089, :end-line 5089, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pv]))}, es6-set-entries-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6224, :column 7, :end-line 6224, :end-column 31, :arglists (quote ([coll]))}, :name cljs.core/es6-set-entries-iterator, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6224, :end-line 6224, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, concat {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3726, :column 7, :end-line 3726, :end-column 13, :arglists (quote ([] [x] [x y] [x y & zs])), :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & zs]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/concat, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & zs]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 3726, :end-line 3726, :max-fixed-arity 2, :fn-var true, :arglists ([] [x] [x y] [x y & zs]), :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls."}, -methods {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10511, :column 4, :end-line 10511, :end-column 12, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-methods, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10505, :end-line 10511, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, js-reserved {:name cljs.core/js-reserved, :file "cljs/core.cljs", :line 10945, :column 1, :end-line 10947, :end-column 14, :jsdoc ["@type {null|Object}"], :meta {:file "cljs/core.cljs", :line 10947, :column 3, :end-line 10947, :end-column 14, :jsdoc ["@type {null|Object}"]}, :tag clj-nil}, IDerefWithTimeout {:meta {:file "cljs/core.cljs", :line 664, :column 14, :end-line 664, :end-column 31, :doc nil, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-deref-with-timeout [[o msec timeout-val]]}}}, :protocol-symbol true, :name cljs.core/IDerefWithTimeout, :file "cljs/core.cljs", :end-column 31, :column 1, :line 664, :protocol-info {:methods {-deref-with-timeout [[o msec timeout-val]]}}, :info nil, :end-line 664, :tag any, :impls #{}, :doc nil, :jsdoc ("@interface")}, symbol {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1082, :column 7, :end-line 1082, :end-column 13, :arglists (quote ([name] [ns name])), :doc "Returns a Symbol with the given namespace and name.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([name] [ns name]), :arglists ([name] [ns name]), :arglists-meta (nil nil)}}, :name cljs.core/symbol, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([name] [ns name]), :arglists ([name] [ns name]), :arglists-meta (nil nil)}, :method-params ([name] [ns name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1082, :end-line 1082, :max-fixed-arity 2, :fn-var true, :arglists ([name] [ns name]), :doc "Returns a Symbol with the given namespace and name."}, to-array-2d {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3606, :column 7, :end-line 3606, :end-column 18, :arglists (quote ([coll])), :doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll."}, :name cljs.core/to-array-2d, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3606, :end-line 3606, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll."}, Subvec {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/Subvec, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 5510, :record false, :end-line 5510, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, ->t_cljs$core10464 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([meta10465])), :file "cljs/core.cljs"}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t_cljs$core10464, :variadic false, :file "cljs/core.cljs", :method-params ([meta10465]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :line 3948, :max-fixed-arity 1, :fn-var true, :arglists (quote ([meta10465])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, ExceptionInfo {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10804, :column 3, :end-line 10804, :end-column 16, :jsdoc ["@constructor"], :arglists (quote ([message data cause]))}, :name cljs.core/ExceptionInfo, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([message data cause]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10803, :end-line 10804, :max-fixed-arity 3, :fn-var true, :arglists (quote ([message data cause])), :jsdoc ["@constructor"]}, mod {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2798, :column 7, :end-line 2798, :end-column 10, :arglists (quote ([n d])), :doc "Modulus of num and div. Truncates toward negative infinity."}, :name cljs.core/mod, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2798, :end-line 2798, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "Modulus of num and div. Truncates toward negative infinity."}, ISet {:meta {:file "cljs/core.cljs", :line 639, :column 14, :end-line 639, :end-column 18, :doc "Protocol for adding set functionality to a collection.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-disjoin [[coll v]]}}}, :protocol-symbol true, :name cljs.core/ISet, :file "cljs/core.cljs", :end-column 18, :column 1, :line 639, :protocol-info {:methods {-disjoin [[coll v]]}}, :info nil, :end-line 639, :tag any, :impls #{cljs.core/PersistentHashSet cljs.core/PersistentTreeSet}, :doc "Protocol for adding set functionality to a collection.", :jsdoc ("@interface")}, pop {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2057, :column 7, :end-line 2057, :end-column 10, :arglists (quote ([coll])), :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast."}, :name cljs.core/pop, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2057, :end-line 2057, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast."}, IPending {:meta {:file "cljs/core.cljs", :line 753, :column 14, :end-line 753, :end-column 22, :doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay and LazySeq.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-realized? [[x]]}}}, :protocol-symbol true, :name cljs.core/IPending, :file "cljs/core.cljs", :end-column 22, :column 1, :line 753, :protocol-info {:methods {-realized? [[x]]}}, :info nil, :end-line 753, :tag any, :impls #{cljs.core/Delay cljs.core/LazySeq}, :doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay and LazySeq.", :jsdoc ("@interface")}, -entry-key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 733, :column 4, :end-line 733, :end-column 14, :protocol cljs.core/ISorted, :doc "Returns the key for entry.", :arglists (quote ([coll entry]))}, :protocol cljs.core/ISorted, :name cljs.core/-entry-key, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll entry]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 721, :end-line 733, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll entry])), :doc "Returns the key for entry."}, CHAR_MAP {:name cljs.core/CHAR_MAP, :file "cljs/core.cljs", :line 323, :column 1, :end-line 324, :end-column 11, :jsdoc ["@enum {string}"], :meta {:file "cljs/core.cljs", :line 324, :column 3, :end-line 324, :end-column 11, :jsdoc ["@enum {string}"]}, :tag object}, pop-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5123, :column 8, :end-line 5123, :end-column 16, :private true, :arglists (quote ([pv level node]))}, :private true, :name cljs.core/pop-tail, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([pv level node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5123, :end-line 5123, :max-fixed-arity 3, :fn-var true, :arglists (quote ([pv level node]))}, dissoc! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3801, :column 7, :end-line 3801, :end-column 14, :arglists (quote ([tcoll key] [tcoll key & ks])), :doc "Returns a transient map that doesn't contain a mapping for key(s).", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([tcoll key]), :arglists ([tcoll key] [tcoll key & ks]), :arglists-meta (nil nil)}}, :name cljs.core/dissoc!, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([tcoll key]), :arglists ([tcoll key] [tcoll key & ks]), :arglists-meta (nil nil)}, :method-params ([tcoll key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3801, :end-line 3801, :max-fixed-arity 2, :fn-var true, :arglists ([tcoll key] [tcoll key & ks]), :doc "Returns a transient map that doesn't contain a mapping for key(s)."}, reductions {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9422, :column 7, :end-line 9422, :end-column 17, :arglists (quote ([f coll] [f init coll])), :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f init coll]), :arglists ([f coll] [f init coll]), :arglists-meta (nil nil)}}, :name cljs.core/reductions, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f init coll]), :arglists ([f coll] [f init coll]), :arglists-meta (nil nil)}, :method-params ([f coll] [f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9422, :end-line 9422, :max-fixed-arity 3, :fn-var true, :arglists ([f coll] [f init coll]), :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init."}, indexed? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1509, :column 16, :end-line 1509, :end-column 24, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll implements nth in constant time"}, :name cljs.core/indexed?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1509, :ret-tag boolean, :end-line 1509, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements nth in constant time"}, - {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2574, :column 15, :end-line 2574, :end-column 16, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/-, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2574, :ret-tag number, :end-line 2574, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result."}, -equiv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 694, :column 13, :end-line 694, :end-column 19, :tag boolean, :protocol cljs.core/IEquiv, :doc "Returns true if o and other are equal, false otherwise.", :arglists (quote ([o other]))}, :protocol cljs.core/IEquiv, :name cljs.core/-equiv, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([o other]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 692, :ret-tag boolean, :end-line 694, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([o other])), :doc "Returns true if o and other are equal, false otherwise."}, ->RangeIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9229, :column 10, :end-line 9229, :end-column 23, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([i end step]))}, :protocols #{cljs.core/Object}, :name cljs.core/->RangeIterator, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([i end step]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 9229, :end-line 9229, :max-fixed-arity 3, :fn-var true, :arglists (quote ([i end step])), :skip-protocol-flag nil}, ->ArrayNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7111, :column 10, :end-line 7111, :end-column 19, :protocols #{cljs.core/Object cljs.core/IIterable}, :skip-protocol-flag #{cljs.core/IIterable}, :factory :positional, :arglists (quote ([edit cnt arr]))}, :protocols #{cljs.core/Object cljs.core/IIterable}, :name cljs.core/->ArrayNode, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([edit cnt arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7111, :end-line 7111, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit cnt arr])), :skip-protocol-flag #{cljs.core/IIterable}}, assoc! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3789, :column 7, :end-line 3789, :end-column 13, :arglists (quote ([tcoll key val] [tcoll key val & kvs])), :doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([tcoll key val]), :arglists ([tcoll key val] [tcoll key val & kvs]), :arglists-meta (nil nil)}}, :name cljs.core/assoc!, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([tcoll key val]), :arglists ([tcoll key val] [tcoll key val & kvs]), :arglists-meta (nil nil)}, :method-params ([tcoll key val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3789, :end-line 3789, :max-fixed-arity 3, :fn-var true, :arglists ([tcoll key val] [tcoll key val & kvs]), :doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll."}, hash-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9028, :column 7, :end-line 9028, :end-column 15, :arglists (quote ([] [& keys])), :doc "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params ([]), :arglists ([] [& keys]), :arglists-meta (nil nil)}}, :name cljs.core/hash-set, :variadic true, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 0, :method-params ([]), :arglists ([] [& keys]), :arglists-meta (nil nil)}, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9028, :end-line 9028, :max-fixed-arity 0, :fn-var true, :arglists ([] [& keys]), :doc "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj."}, reduce-kv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2521, :column 7, :end-line 2521, :end-column 16, :arglists (quote ([f init coll])), :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals."}, :name cljs.core/reduce-kv, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2521, :end-line 2521, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f init coll])), :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals."}, reset! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4410, :column 7, :end-line 4410, :end-column 13, :arglists (quote ([a new-value])), :doc "Sets the value of atom to newval without regard for the\n  current value. Returns new-value."}, :name cljs.core/reset!, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([a new-value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4410, :end-line 4410, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a new-value])), :doc "Sets the value of atom to newval without regard for the\n  current value. Returns new-value."}, name {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9097, :column 7, :end-line 9097, :end-column 11, :arglists (quote ([x])), :doc "Returns the name String of a string, symbol or keyword."}, :name cljs.core/name, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9097, :end-line 9097, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns the name String of a string, symbol or keyword."}, ->RedNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8079, :column 10, :end-line 8079, :end-column 17, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :factory :positional, :arglists (quote ([key val left right __hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->RedNode, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([key val left right __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 8079, :end-line 8079, :max-fixed-arity 5, :fn-var true, :arglists (quote ([key val left right __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, unchecked-array-for {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5097, :column 8, :end-line 5097, :end-column 27, :private true, :arglists (quote ([pv i]))}, :private true, :name cljs.core/unchecked-array-for, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([pv i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5097, :end-line 5097, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pv i]))}, Fn {:meta {:file "cljs/core.cljs", :line 522, :column 14, :end-line 522, :end-column 16, :doc "Marker protocol", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/Fn, :file "cljs/core.cljs", :end-column 16, :column 1, :line 522, :protocol-info {:methods {}}, :info nil, :end-line 522, :tag any, :impls #{cljs.core/Var function cljs.core/MetaFn}, :doc "Marker protocol", :jsdoc ("@interface")}, ffirst {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1729, :column 7, :end-line 1729, :end-column 13, :arglists (quote ([coll])), :doc "Same as (first (first x))"}, :name cljs.core/ffirst, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1729, :end-line 1729, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (first x))"}, ->ArrayNodeIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7091, :column 10, :end-line 7091, :end-column 27, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([arr i next-iter]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayNodeIterator, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([arr i next-iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7091, :end-line 7091, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i next-iter])), :skip-protocol-flag nil}, sorted-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9034, :column 7, :end-line 9034, :end-column 17, :arglists (quote ([& keys])), :doc "Returns a new sorted set with supplied keys.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keys)], :arglists ([& keys]), :arglists-meta (nil)}}, :name cljs.core/sorted-set, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keys)], :arglists ([& keys]), :arglists-meta (nil)}, :method-params [(keys)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9034, :end-line 9034, :max-fixed-arity 0, :fn-var true, :arglists ([& keys]), :doc "Returns a new sorted set with supplied keys."}, pr-with-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9735, :column 8, :end-line 9735, :end-column 20, :private true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects using string-print, observing all\n  the options given in opts"}, :private true, :name cljs.core/pr-with-opts, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9735, :end-line 9735, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects using string-print, observing all\n  the options given in opts"}, PersistentTreeMap {:num-fields 5, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/PersistentTreeMap, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 8347, :record false, :end-line 8347, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, strip-ns {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9798, :column 8, :end-line 9798, :end-column 16, :private true, :arglists (quote ([named]))}, :private true, :name cljs.core/strip-ns, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([named]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9798, :end-line 9798, :max-fixed-arity 1, :fn-var true, :arglists (quote ([named]))}, ->PersistentTreeMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8347, :column 10, :end-line 8347, :end-column 27, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :factory :positional, :arglists (quote ([comp tree cnt meta __hash]))}, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->PersistentTreeMap, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([comp tree cnt meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 8347, :end-line 8347, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp tree cnt meta __hash])), :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, array-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1472, :column 8, :end-line 1472, :end-column 20, :private true, :arglists (quote ([arr f] [arr f val] [arr f val idx])), :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([arr f] [arr f val] [arr f val idx]), :arglists ([arr f] [arr f val] [arr f val idx]), :arglists-meta (nil nil nil)}}, :private true, :name cljs.core/array-reduce, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([arr f] [arr f val] [arr f val idx]), :arglists ([arr f] [arr f val] [arr f val idx]), :arglists-meta (nil nil nil)}, :method-params ([arr f] [arr f val] [arr f val idx]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1472, :end-line 1472, :max-fixed-arity 4, :fn-var true, :arglists ([arr f] [arr f val] [arr f val idx])}, counted? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1505, :column 16, :end-line 1505, :end-column 24, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll implements count in constant time"}, :name cljs.core/counted?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1505, :ret-tag boolean, :end-line 1505, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements count in constant time"}, tagged-literal {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10920, :column 7, :end-line 10920, :end-column 21, :arglists (quote ([tag form])), :doc "Construct a data representation of a tagged literal from a\n  tag symbol and a form."}, :name cljs.core/tagged-literal, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([tag form]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10920, :end-line 10920, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag form])), :doc "Construct a data representation of a tagged literal from a\n  tag symbol and a form."}, println {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9779, :column 7, :end-line 9779, :end-column 14, :arglists (quote ([& objs])), :doc "Same as print followed by (newline)", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/println, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9779, :end-line 9779, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "Same as print followed by (newline)"}, assoc-in {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4986, :column 7, :end-line 4986, :end-column 15, :arglists (quote ([m [k & ks] v])), :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created."}, :name cljs.core/assoc-in, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([m p__14852 v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4986, :end-line 4986, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m [k & ks] v])), :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created."}, PersistentHashSet {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/PersistentHashSet, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 8755, :record false, :end-line 8755, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/ILookup}}, bit-test {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2858, :column 16, :end-line 2858, :end-column 24, :tag boolean, :arglists (quote ([x n])), :doc "Test bit at index n"}, :name cljs.core/bit-test, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2858, :ret-tag boolean, :end-line 2858, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x n])), :doc "Test bit at index n"}, ->Namespace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11027, :column 10, :end-line 11027, :end-column 19, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash}, :factory :positional, :arglists (quote ([obj name]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object}, :name cljs.core/->Namespace, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([obj name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 11027, :end-line 11027, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj name])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash}}, TransientHashMap {:meta {:file "cljs/core.cljs", :line 6764, :column 10, :end-line 6764, :end-column 26, :declared true}, :num-fields 5, :protocols #{cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientHashMap, :file "cljs/core.cljs", :end-column 26, :type true, :column 10, :line 7673, :record false, :declared true, :end-line 7673, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, ->PersistentHashMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7498, :column 10, :end-line 7498, :end-column 27, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :factory :positional, :arglists (quote ([meta cnt root has-nil? nil-val __hash]))}, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->PersistentHashMap, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([meta cnt root has-nil? nil-val __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7498, :end-line 7498, :max-fixed-arity 6, :fn-var true, :arglists (quote ([meta cnt root has-nil? nil-val __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, array-extend-kv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6290, :column 8, :end-line 6290, :end-column 23, :private true, :arglists (quote ([arr k v]))}, :private true, :name cljs.core/array-extend-kv, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([arr k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6290, :end-line 6290, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr k v]))}, ISwap {:meta {:file "cljs/core.cljs", :line 842, :column 14, :end-line 842, :end-column 19, :doc "Protocol for adding swapping functionality.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-swap! [[o f] [o f a] [o f a b] [o f a b xs]]}}}, :protocol-symbol true, :name cljs.core/ISwap, :file "cljs/core.cljs", :end-column 19, :column 1, :line 842, :protocol-info {:methods {-swap! [[o f] [o f a] [o f a b] [o f a b xs]]}}, :info nil, :end-line 842, :tag any, :impls #{}, :doc "Protocol for adding swapping functionality.", :jsdoc ("@interface")}, ChunkedCons {:meta {:file "cljs/core.cljs", :line 2135, :column 10, :end-line 2135, :end-column 21, :declared true}, :num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/ChunkedCons, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 3500, :record false, :declared true, :end-line 3500, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}}, memoize {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10273, :column 7, :end-line 10273, :end-column 14, :arglists (quote ([f])), :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use."}, :name cljs.core/memoize, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10273, :end-line 10273, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use."}, alter-meta! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9992, :column 7, :end-line 9992, :end-column 18, :arglists (quote ([iref f & args])), :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(iref f args)], :arglists ([iref f & args]), :arglists-meta (nil)}}, :name cljs.core/alter-meta!, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(iref f args)], :arglists ([iref f & args]), :arglists-meta (nil)}, :method-params [(iref f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9992, :end-line 9992, :max-fixed-arity 2, :fn-var true, :arglists ([iref f & args]), :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects"}, ->StringBufferWriter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 860, :column 10, :end-line 860, :end-column 28, :protocols #{cljs.core/IWriter}, :skip-protocol-flag #{cljs.core/IWriter}, :factory :positional, :arglists (quote ([sb]))}, :protocols #{cljs.core/IWriter}, :name cljs.core/->StringBufferWriter, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([sb]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 860, :end-line 860, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sb])), :skip-protocol-flag #{cljs.core/IWriter}}, zero? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2903, :column 16, :end-line 2903, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if num is zero, else false"}, :name cljs.core/zero?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2903, :ret-tag boolean, :end-line 2903, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if num is zero, else false"}, tv-ensure-editable {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5669, :column 8, :end-line 5669, :end-column 26, :private true, :arglists (quote ([edit node]))}, :private true, :name cljs.core/tv-ensure-editable, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([edit node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5669, :end-line 5669, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit node]))}, simple-keyword? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3339, :column 16, :end-line 3339, :end-column 31, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a keyword without a namespace"}, :name cljs.core/simple-keyword?, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3339, :ret-tag boolean, :end-line 3339, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a keyword without a namespace"}, -indexOf {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1513, :column 8, :end-line 1513, :end-column 16, :private true, :arglists (quote ([coll x] [coll x start])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll x] [coll x start]), :arglists ([coll x] [coll x start]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/-indexOf, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll x] [coll x start]), :arglists ([coll x] [coll x start]), :arglists-meta (nil nil)}, :method-params ([coll x] [coll x start]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1513, :end-line 1513, :max-fixed-arity 3, :fn-var true, :arglists ([coll x] [coll x start])}, *main-cli-fn* {:name cljs.core/*main-cli-fn*, :file "cljs/core.cljs", :line 282, :column 1, :end-line 286, :end-column 16, :doc "When compiled for a command-line target, whatever function\n  *main-cli-fn* is set to will be called with the command-line\n  argv as arguments", :meta {:file "cljs/core.cljs", :line 286, :column 3, :end-line 286, :end-column 16, :doc "When compiled for a command-line target, whatever function\n  *main-cli-fn* is set to will be called with the command-line\n  argv as arguments"}, :tag clj-nil}, -assoc-n {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 656, :column 9, :end-line 656, :end-column 17, :tag clj, :protocol cljs.core/IVector, :doc "Returns a new vector with value val added at position n.", :arglists (quote ([coll n val]))}, :protocol cljs.core/IVector, :name cljs.core/-assoc-n, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll n val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 654, :ret-tag clj, :end-line 656, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll n val])), :doc "Returns a new vector with value val added at position n."}, unchecked-dec-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2702, :column 7, :end-line 2702, :end-column 24, :arglists (quote ([x])), :doc "Returns a number one less than x, an int."}, :name cljs.core/unchecked-dec-int, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2702, :end-line 2702, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one less than x, an int."}, hash-imap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2971, :column 8, :end-line 2971, :end-column 17, :private true, :arglists (quote ([m]))}, :private true, :name cljs.core/hash-imap, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2971, :end-line 2971, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m]))}, dominates {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10473, :column 8, :end-line 10473, :end-column 17, :private true, :arglists (quote ([x y prefer-table hierarchy]))}, :private true, :name cljs.core/dominates, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x y prefer-table hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10473, :end-line 10473, :max-fixed-arity 4, :fn-var true, :arglists (quote ([x y prefer-table hierarchy]))}, persistent! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3769, :column 7, :end-line 3769, :end-column 18, :arglists (quote ([tcoll])), :doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception."}, :name cljs.core/persistent!, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3769, :end-line 3769, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tcoll])), :doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception."}, set-print-fn! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 76, :column 7, :end-line 76, :end-column 20, :arglists (quote ([f])), :doc "Set *print-fn* to f."}, :name cljs.core/set-print-fn!, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 76, :end-line 76, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Set *print-fn* to f."}, nnext {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1744, :column 7, :end-line 1744, :end-column 12, :arglists (quote ([coll])), :doc "Same as (next (next x))"}, :name cljs.core/nnext, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1744, :end-line 1744, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (next (next x))"}, Box {:num-fields 1, :protocols #{}, :name cljs.core/Box, :file "cljs/core.cljs", :end-column 13, :type true, :column 10, :line 6775, :record false, :end-line 6775, :skip-protocol-flag nil}, balance-right {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7884, :column 8, :end-line 7884, :end-column 21, :private true, :arglists (quote ([key val left ins]))}, :private true, :name cljs.core/balance-right, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([key val left ins]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7884, :end-line 7884, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val left ins]))}, throw-no-method-error {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10516, :column 8, :end-line 10516, :end-column 29, :private true, :arglists (quote ([name dispatch-val]))}, :private true, :name cljs.core/throw-no-method-error, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([name dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10516, :end-line 10516, :max-fixed-arity 2, :fn-var true, :arglists (quote ([name dispatch-val]))}, demunge-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10994, :column 8, :end-line 10994, :end-column 19, :private true, :arglists (quote ([munged-name]))}, :private true, :name cljs.core/demunge-str, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([munged-name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10994, :end-line 10994, :max-fixed-arity 1, :fn-var true, :arglists (quote ([munged-name]))}, add-watch {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10006, :column 7, :end-line 10006, :end-column 16, :arglists (quote ([iref key f])), :doc "Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom's state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom's value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;=> 1"}, :name cljs.core/add-watch, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([iref key f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10006, :end-line 10006, :max-fixed-arity 3, :fn-var true, :arglists (quote ([iref key f])), :doc "Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom's state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom's value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;=> 1"}, not-every? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4174, :column 16, :end-line 4174, :end-column 26, :tag boolean, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for every x in\n  coll, else true."}, :name cljs.core/not-every?, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4174, :ret-tag boolean, :end-line 4174, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for every x in\n  coll, else true."}, rem {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2809, :column 7, :end-line 2809, :end-column 10, :arglists (quote ([n d])), :doc "remainder of dividing numerator by denominator."}, :name cljs.core/rem, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2809, :end-line 2809, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "remainder of dividing numerator by denominator."}, ifind? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2103, :column 16, :end-line 2103, :end-column 22, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll implements IFind"}, :name cljs.core/ifind?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2103, :ret-tag boolean, :end-line 2103, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements IFind"}, pr-sb-with-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9711, :column 8, :end-line 9711, :end-column 23, :private true, :arglists (quote ([objs opts]))}, :private true, :name cljs.core/pr-sb-with-opts, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9711, :end-line 9711, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts]))}, ->HashMapIter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7486, :column 10, :end-line 7486, :end-column 21, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([nil-val root-iter seen]))}, :protocols #{cljs.core/Object}, :name cljs.core/->HashMapIter, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([nil-val root-iter seen]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7486, :end-line 7486, :max-fixed-arity 3, :fn-var true, :arglists (quote ([nil-val root-iter seen])), :skip-protocol-flag nil}, BitmapIndexedNode {:num-fields 3, :protocols #{cljs.core/Object cljs.core/IIterable}, :name cljs.core/BitmapIndexedNode, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 6876, :record false, :end-line 6876, :skip-protocol-flag #{cljs.core/IIterable}}, ->NodeSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7341, :column 10, :end-line 7341, :end-column 17, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta nodes i s __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->NodeSeq, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([meta nodes i s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7341, :end-line 7341, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta nodes i s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, some {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4179, :column 7, :end-line 4179, :end-column 11, :arglists (quote ([pred coll])), :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)"}, :name cljs.core/some, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4179, :end-line 4179, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)"}, INamed {:meta {:file "cljs/core.cljs", :line 827, :column 14, :end-line 827, :end-column 20, :doc "Protocol for adding a name.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-name [[x]], -namespace [[x]]}}}, :protocol-symbol true, :name cljs.core/INamed, :file "cljs/core.cljs", :end-column 20, :column 1, :line 827, :protocol-info {:methods {-name [[x]], -namespace [[x]]}}, :info nil, :end-line 827, :tag any, :impls #{cljs.core/MultiFn cljs.core/Keyword cljs.core/Symbol}, :doc "Protocol for adding a name.", :jsdoc ("@interface")}, ->Box {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6775, :column 10, :end-line 6775, :end-column 13, :protocols #{}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([val]))}, :protocols #{}, :name cljs.core/->Box, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6775, :end-line 6775, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :skip-protocol-flag nil}, IReduce {:meta {:file "cljs/core.cljs", :line 677, :column 14, :end-line 677, :end-column 21, :doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-reduce [[coll f] [coll f start]]}}}, :protocol-symbol true, :name cljs.core/IReduce, :file "cljs/core.cljs", :end-column 21, :column 1, :line 677, :protocol-info {:methods {-reduce [[coll f] [coll f start]]}}, :info nil, :end-line 677, :tag any, :impls #{cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ArrayChunk cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce.", :jsdoc ("@interface")}, neg-int? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2259, :column 16, :end-line 2259, :end-column 24, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies int? and is negative."}, :name cljs.core/neg-int?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2259, :ret-tag boolean, :end-line 2259, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies int? and is negative."}, drop {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4685, :column 7, :end-line 4685, :end-column 11, :arglists (quote ([n] [n coll])), :doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/drop, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4685, :end-line 4685, :max-fixed-arity 2, :fn-var true, :arglists ([n] [n coll]), :doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided."}, NodeIterator {:num-fields 4, :protocols #{cljs.core/Object}, :name cljs.core/NodeIterator, :file "cljs/core.cljs", :end-column 23, :type true, :column 11, :line 6838, :record false, :end-line 6838, :skip-protocol-flag nil}, js-obj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2142, :column 7, :end-line 2142, :end-column 13, :arglists (quote ([] [& keyvals])), :doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params ([]), :arglists ([] [& keyvals]), :arglists-meta (nil nil)}}, :name cljs.core/js-obj, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 0, :method-params ([]), :arglists ([] [& keyvals]), :arglists-meta (nil nil)}, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2142, :end-line 2142, :max-fixed-arity 0, :fn-var true, :arglists ([] [& keyvals]), :doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values."}, ITransientCollection {:meta {:file "cljs/core.cljs", :line 774, :column 14, :end-line 774, :end-column 34, :doc "Protocol for adding basic functionality to transient collections.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-conj! [[tcoll val]], -persistent! [[tcoll]]}}}, :protocol-symbol true, :name cljs.core/ITransientCollection, :file "cljs/core.cljs", :end-column 34, :column 1, :line 774, :protocol-info {:methods {-conj! [[tcoll val]], -persistent! [[tcoll]]}}, :info nil, :end-line 774, :tag any, :impls #{cljs.core/TransientVector cljs.core/TransientHashMap cljs.core/TransientArrayMap cljs.core/TransientHashSet}, :doc "Protocol for adding basic functionality to transient collections.", :jsdoc ("@interface")}, Atom {:num-fields 4, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/Atom, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 4362, :record false, :end-line 4362, :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}}, nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1829, :column 7, :end-line 1829, :end-column 10, :arglists (quote ([coll n] [coll n not-found])), :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}}, :name cljs.core/nth, :variadic false, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1829, :end-line 1829, :max-fixed-arity 3, :fn-var true, :arglists ([coll n] [coll n not-found]), :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences."}, sorted? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2111, :column 16, :end-line 2111, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISorted"}, :name cljs.core/sorted?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2111, :ret-tag boolean, :end-line 2111, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISorted"}, nil? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 217, :column 16, :end-line 217, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is nil, false otherwise."}, :name cljs.core/nil?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 217, :ret-tag boolean, :end-line 217, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is nil, false otherwise."}, split-at {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4755, :column 7, :end-line 4755, :end-column 15, :arglists (quote ([n coll])), :doc "Returns a vector of [(take n coll) (drop n coll)]"}, :name cljs.core/split-at, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4755, :end-line 4755, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "Returns a vector of [(take n coll) (drop n coll)]"}, TransientHashSet {:meta {:file "cljs/core.cljs", :line 8743, :column 10, :end-line 8743, :end-column 26, :declared true}, :num-fields 1, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name cljs.core/TransientHashSet, :file "cljs/core.cljs", :end-column 26, :type true, :column 10, :line 8873, :record false, :declared true, :end-line 8873, :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}}, *e {:name cljs.core/*e, :file "cljs/core.cljs", :line 199, :column 1, :end-line 201, :end-column 5, :doc "bound in a repl thread to the most recent exception caught by the repl", :meta {:file "cljs/core.cljs", :line 201, :column 3, :end-line 201, :end-column 5, :doc "bound in a repl thread to the most recent exception caught by the repl"}}, array-map-extend-kv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6301, :column 8, :end-line 6301, :end-column 27, :private true, :arglists (quote ([m k v]))}, :private true, :name cljs.core/array-map-extend-kv, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([m k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6301, :end-line 6301, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m k v]))}, prn-str-with-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9726, :column 7, :end-line 9726, :end-column 24, :arglists (quote ([objs opts])), :doc "Same as pr-str-with-opts followed by (newline)"}, :name cljs.core/prn-str-with-opts, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9726, :end-line 9726, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Same as pr-str-with-opts followed by (newline)"}, not-native {:name cljs.core/not-native, :file "cljs/core.cljs", :line 208, :column 1, :end-line 208, :end-column 16, :meta {:file "cljs/core.cljs", :line 208, :column 6, :end-line 208, :end-column 16}, :tag clj-nil}, random-sample {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10148, :column 7, :end-line 10148, :end-column 20, :arglists (quote ([prob] [prob coll])), :doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([prob] [prob coll]), :arglists ([prob] [prob coll]), :arglists-meta (nil nil)}}, :name cljs.core/random-sample, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([prob] [prob coll]), :arglists ([prob] [prob coll]), :arglists-meta (nil nil)}, :method-params ([prob] [prob coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10148, :end-line 10148, :max-fixed-arity 2, :fn-var true, :arglists ([prob] [prob coll]), :doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided."}, select-keys {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8727, :column 7, :end-line 8727, :end-column 18, :arglists (quote ([map keyseq])), :doc "Returns a map containing only those entries in map whose key is in keys"}, :name cljs.core/select-keys, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([map keyseq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8727, :end-line 8727, :max-fixed-arity 2, :fn-var true, :arglists (quote ([map keyseq])), :doc "Returns a map containing only those entries in map whose key is in keys"}, bit-and {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2821, :column 7, :end-line 2821, :end-column 14, :arglists (quote ([x y] [x y & more])), :doc "Bitwise and", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}}, :name cljs.core/bit-and, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2821, :end-line 2821, :max-fixed-arity 2, :fn-var true, :arglists ([x y] [x y & more]), :doc "Bitwise and"}, bounded-count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3705, :column 7, :end-line 3705, :end-column 20, :arglists (quote ([n coll])), :doc "If coll is counted? returns its count, else will count at most the first n\n   elements of coll using its seq", :added "1.9"}, :added "1.9", :name cljs.core/bounded-count, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3705, :end-line 3705, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "If coll is counted? returns its count, else will count at most the first n\n   elements of coll using its seq"}, update {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5022, :column 7, :end-line 5022, :end-column 13, :arglists (quote ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more])), :doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([m k f] [m k f x] [m k f x y] [m k f x y z]), :arglists ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/update, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([m k f] [m k f x] [m k f x y] [m k f x y z]), :arglists ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]), :arglists-meta (nil nil nil nil nil)}, :method-params ([m k f] [m k f x] [m k f x y] [m k f x y z]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 5022, :end-line 5022, :max-fixed-arity 6, :fn-var true, :arglists ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]), :doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value."}, gensym_counter {:name cljs.core/gensym_counter, :file "cljs/core.cljs", :line 10037, :column 1, :end-line 10039, :end-column 17, :jsdoc ["@type {*}"], :meta {:file "cljs/core.cljs", :line 10039, :column 3, :end-line 10039, :end-column 17, :jsdoc ["@type {*}"]}, :tag clj-nil}, find-macros-ns {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11117, :column 7, :end-line 11117, :end-column 21, :arglists (quote ([ns])), :doc "Returns the macros namespace named by the symbol or nil if it doesn't exist.\n  Bootstrap only."}, :name cljs.core/find-macros-ns, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([ns]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 11117, :end-line 11117, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ns])), :doc "Returns the macros namespace named by the symbol or nil if it doesn't exist.\n  Bootstrap only."}, list* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3751, :column 7, :end-line 3751, :end-column 12, :arglists (quote ([args] [a args] [a b args] [a b c args] [a b c d & more])), :doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([args] [a args] [a b args] [a b c args]), :arglists ([args] [a args] [a b args] [a b c args] [a b c d & more]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/list*, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([args] [a args] [a b args] [a b c args]), :arglists ([args] [a args] [a b args] [a b c args] [a b c d & more]), :arglists-meta (nil nil nil nil nil)}, :method-params ([args] [a args] [a b args] [a b c args]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 3751, :end-line 3751, :max-fixed-arity 4, :fn-var true, :arglists ([args] [a args] [a b args] [a b c args] [a b c d & more]), :doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence."}, array-index-of-keyword? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6237, :column 8, :end-line 6237, :end-column 31, :private true, :arglists (quote ([arr k]))}, :private true, :name cljs.core/array-index-of-keyword?, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6237, :end-line 6237, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, ->Keyword {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3261, :column 10, :end-line 3261, :end-column 17, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}, :factory :positional, :arglists (quote ([ns name fqn _hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :name cljs.core/->Keyword, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([ns name fqn _hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3261, :end-line 3261, :max-fixed-arity 4, :fn-var true, :arglists (quote ([ns name fqn _hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}}, update-in {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4995, :column 7, :end-line 4995, :end-column 16, :arglists (quote ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args])), :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c]), :arglists ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/update-in, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c]), :arglists ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args]), :arglists-meta (nil nil nil nil nil)}, :method-params ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 4995, :end-line 4995, :max-fixed-arity 6, :fn-var true, :arglists ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args]), :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created."}, prefer-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10714, :column 7, :end-line 10714, :end-column 20, :arglists (quote ([multifn dispatch-val-x dispatch-val-y])), :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict"}, :name cljs.core/prefer-method, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([multifn dispatch-val-x dispatch-val-y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10714, :end-line 10714, :max-fixed-arity 3, :fn-var true, :arglists (quote ([multifn dispatch-val-x dispatch-val-y])), :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict"}, hash-symbol {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1029, :column 8, :end-line 1029, :end-column 19, :private true, :arglists (quote ([sym]))}, :private true, :name cljs.core/hash-symbol, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1029, :end-line 1029, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym]))}, ensure-reduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1419, :column 7, :end-line 1419, :end-column 21, :arglists (quote ([x])), :doc "If x is already reduced?, returns it, else returns (reduced x)"}, :name cljs.core/ensure-reduced, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1419, :end-line 1419, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is already reduced?, returns it, else returns (reduced x)"}, edit-and-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6809, :column 8, :end-line 6809, :end-column 20, :private true, :arglists (quote ([inode edit i a] [inode edit i a j b])), :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([inode edit i a] [inode edit i a j b]), :arglists ([inode edit i a] [inode edit i a j b]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/edit-and-set, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([inode edit i a] [inode edit i a j b]), :arglists ([inode edit i a] [inode edit i a j b]), :arglists-meta (nil nil)}, :method-params ([inode edit i a] [inode edit i a j b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6809, :end-line 6809, :max-fixed-arity 6, :fn-var true, :arglists ([inode edit i a] [inode edit i a j b])}, ->PersistentArrayMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6476, :column 10, :end-line 6476, :end-column 28, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta cnt arr __hash]))}, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->PersistentArrayMap, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([meta cnt arr __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6476, :end-line 6476, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta cnt arr __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}}, instance? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1018, :column 16, :end-line 1018, :end-column 25, :tag boolean, :arglists (quote ([c x])), :doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false"}, :name cljs.core/instance?, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([c x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1018, :ret-tag boolean, :end-line 1018, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([c x])), :doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false"}, mix-collection-hash {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1301, :column 15, :end-line 1301, :end-column 34, :tag number, :arglists (quote ([hash-basis count])), :doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms."}, :name cljs.core/mix-collection-hash, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([hash-basis count]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1301, :ret-tag number, :end-line 1301, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([hash-basis count])), :doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms."}, re-find {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9520, :column 7, :end-line 9520, :end-column 14, :arglists (quote ([re s])), :doc "Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups."}, :name cljs.core/re-find, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9520, :end-line 9520, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups."}, run! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10195, :column 7, :end-line 10195, :end-column 11, :arglists (quote ([proc coll])), :doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil"}, :name cljs.core/run!, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([proc coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10195, :end-line 10195, :max-fixed-arity 2, :fn-var true, :arglists (quote ([proc coll])), :doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil"}, char-escapes {:name cljs.core/char-escapes, :file "cljs/core.cljs", :line 9590, :column 1, :end-line 9590, :end-column 28, :private true, :meta {:file "cljs/core.cljs", :line 9590, :column 16, :end-line 9590, :end-column 28, :private true}, :tag object}, ES6Iterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6Iterator, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 1265, :record false, :end-line 1265, :skip-protocol-flag nil}, val {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8698, :column 7, :end-line 8698, :end-column 10, :arglists (quote ([map-entry])), :doc "Returns the value in the map entry."}, :name cljs.core/val, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([map-entry]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8698, :end-line 8698, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-entry])), :doc "Returns the value in the map entry."}, unchecked-add {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2683, :column 15, :end-line 2683, :end-column 28, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/unchecked-add, :variadic true, :file "cljs/core.cljs", :end-column 28, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 2683, :ret-tag number, :end-line 2683, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the sum of nums. (+) returns 0."}, transformer-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4123, :column 7, :end-line 4123, :end-column 27, :arglists (quote ([xform sourceIter multi]))}, :name cljs.core/transformer-iterator, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([xform sourceIter multi]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4123, :end-line 4123, :max-fixed-arity 3, :fn-var true, :arglists (quote ([xform sourceIter multi]))}, not {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 234, :column 16, :end-line 234, :end-column 19, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is logical false, false otherwise."}, :name cljs.core/not, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 234, :ret-tag boolean, :end-line 234, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is logical false, false otherwise."}, -vreset! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 849, :column 4, :end-line 849, :end-column 12, :protocol cljs.core/IVolatile, :doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value.", :arglists (quote ([o new-value]))}, :protocol cljs.core/IVolatile, :name cljs.core/-vreset!, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([o new-value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 847, :end-line 849, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o new-value])), :doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value."}, fn->comparator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2385, :column 17, :end-line 2385, :end-column 31, :private true, :arglists (quote ([f])), :doc "Given a fn that might be boolean valued or a comparator,\n   return a fn that is a comparator."}, :private true, :name cljs.core/fn->comparator, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2385, :end-line 2385, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Given a fn that might be boolean valued or a comparator,\n   return a fn that is a comparator."}, with-meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2034, :column 7, :end-line 2034, :end-column 16, :arglists (quote ([o meta])), :doc "Returns an object of the same type and value as obj, with\n  map m as its metadata."}, :name cljs.core/with-meta, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([o meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2034, :end-line 2034, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o meta])), :doc "Returns an object of the same type and value as obj, with\n  map m as its metadata."}, unreduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1424, :column 7, :end-line 1424, :end-column 16, :arglists (quote ([x])), :doc "If x is reduced?, returns (deref x), else returns x"}, :name cljs.core/unreduced, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1424, :end-line 1424, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is reduced?, returns (deref x), else returns x"}, record? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2126, :column 16, :end-line 2126, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies IRecord"}, :name cljs.core/record?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2126, :ret-tag boolean, :end-line 2126, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IRecord"}, type {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 293, :column 7, :end-line 293, :end-column 11, :arglists (quote ([x])), :doc "Return x's constructor."}, :name cljs.core/type, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 293, :end-line 293, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return x's constructor."}, identical? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 212, :column 16, :end-line 212, :end-column 26, :tag boolean, :arglists (quote ([x y])), :doc "Tests if 2 arguments are the same object"}, :name cljs.core/identical?, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 212, :ret-tag boolean, :end-line 212, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x y])), :doc "Tests if 2 arguments are the same object"}, -namespace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 831, :column 12, :end-line 831, :end-column 22, :tag string, :protocol cljs.core/INamed, :doc "Returns the namespace String of x.", :arglists (quote ([x]))}, :protocol cljs.core/INamed, :name cljs.core/-namespace, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 827, :ret-tag string, :end-line 831, :max-fixed-arity 1, :tag string, :fn-var true, :arglists (quote ([x])), :doc "Returns the namespace String of x."}, unchecked-divide-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2707, :column 15, :end-line 2707, :end-column 35, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/unchecked-divide-int, :variadic true, :file "cljs/core.cljs", :end-column 35, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2707, :ret-tag number, :end-line 2707, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators."}, ns-name {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11136, :column 7, :end-line 11136, :end-column 14, :arglists (quote ([ns-obj])), :doc "Returns the name of the namespace, a Namespace object.\n  Bootstrap only."}, :name cljs.core/ns-name, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([ns-obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 11136, :end-line 11136, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ns-obj])), :doc "Returns the name of the namespace, a Namespace object.\n  Bootstrap only."}, swap-global-hierarchy! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10347, :column 8, :end-line 10347, :end-column 30, :private true, :arglists (quote ([f & args])), :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}}, :private true, :name cljs.core/swap-global-hierarchy!, :variadic true, :file "cljs/core.cljs", :end-column 30, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}, :method-params [(f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 10347, :end-line 10347, :max-fixed-arity 1, :fn-var true, :arglists ([f & args])}, max-key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9118, :column 7, :end-line 9118, :end-column 14, :arglists (quote ([k x] [k x y] [k x y & more])), :doc "Returns the x for which (k x), a number, is greatest.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([k x] [k x y]), :arglists ([k x] [k x y] [k x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/max-key, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([k x] [k x y]), :arglists ([k x] [k x y] [k x y & more]), :arglists-meta (nil nil nil)}, :method-params ([k x] [k x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 9118, :end-line 9118, :max-fixed-arity 3, :fn-var true, :arglists ([k x] [k x y] [k x y & more]), :doc "Returns the x for which (k x), a number, is greatest."}, ->PersistentTreeSet {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8910, :column 10, :end-line 8910, :end-column 27, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :factory :positional, :arglists (quote ([meta tree-map __hash]))}, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/->PersistentTreeSet, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([meta tree-map __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 8910, :end-line 8910, :max-fixed-arity 3, :fn-var true, :arglists (quote ([meta tree-map __hash])), :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, *out* {:meta {:file "cljs/core.cljs", :line 58, :column 3, :end-line 58, :end-column 8, :dynamic true, :jsdoc ["@type {*}"]}, :name cljs.core/*out*, :file "cljs/core.cljs", :end-column 8, :column 1, :dynamic true, :line 55, :end-line 58, :tag clj-nil, :jsdoc ["@type {*}"]}, ->ChunkBuffer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3451, :column 10, :end-line 3451, :end-column 21, :protocols #{cljs.core/Object cljs.core/ICounted}, :skip-protocol-flag #{cljs.core/ICounted}, :factory :positional, :arglists (quote ([buf end]))}, :protocols #{cljs.core/Object cljs.core/ICounted}, :name cljs.core/->ChunkBuffer, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([buf end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3451, :end-line 3451, :max-fixed-arity 2, :fn-var true, :arglists (quote ([buf end])), :skip-protocol-flag #{cljs.core/ICounted}}, hash-string {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 964, :column 7, :end-line 964, :end-column 18, :arglists (quote ([k]))}, :name cljs.core/hash-string, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 964, :end-line 964, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, ValSeq {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ValSeq, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 8627, :record false, :end-line 8627, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -prefers {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10512, :column 4, :end-line 10512, :end-column 12, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-prefers, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10505, :end-line 10512, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, set-validator! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4457, :column 7, :end-line 4457, :end-column 21, :arglists (quote ([iref val])), :doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed."}, :name cljs.core/set-validator!, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([iref val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4457, :end-line 4457, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref val])), :doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed."}, ident? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3319, :column 16, :end-line 3319, :end-column 22, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a symbol or keyword"}, :name cljs.core/ident?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3319, :ret-tag boolean, :end-line 3319, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a symbol or keyword"}, -meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 669, :column 16, :end-line 669, :end-column 21, :tag clj-or-nil, :protocol cljs.core/IMeta, :doc "Returns the metadata of object o.", :arglists (quote ([o]))}, :protocol cljs.core/IMeta, :name cljs.core/-meta, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 667, :ret-tag clj-or-nil, :end-line 669, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([o])), :doc "Returns the metadata of object o."}, RedNode {:meta {:file "cljs/core.cljs", :line 7857, :column 10, :end-line 7857, :end-column 17, :declared true}, :num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/RedNode, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 8079, :record false, :declared true, :end-line 8079, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, -dispatch-fn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10514, :column 4, :end-line 10514, :end-column 16, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-dispatch-fn, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10505, :end-line 10514, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, ->IndexedSeqIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1547, :column 10, :end-line 1547, :end-column 28, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([arr i]))}, :protocols #{cljs.core/Object}, :name cljs.core/->IndexedSeqIterator, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1547, :end-line 1547, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag nil}, -add-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10507, :column 4, :end-line 10507, :end-column 15, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf dispatch-val method]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-add-method, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([mf dispatch-val method]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10505, :end-line 10507, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf dispatch-val method])), :doc nil}, balance-left-del {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7906, :column 8, :end-line 7906, :end-column 24, :private true, :arglists (quote ([key val del right]))}, :private true, :name cljs.core/balance-left-del, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([key val del right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7906, :end-line 7906, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val del right]))}, swap! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4426, :column 7, :end-line 4426, :end-column 12, :arglists (quote ([a f] [a f x] [a f x y] [a f x y & more])), :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([a f] [a f x] [a f x y]), :arglists ([a f] [a f x] [a f x y] [a f x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/swap!, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([a f] [a f x] [a f x y]), :arglists ([a f] [a f x] [a f x y] [a f x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([a f] [a f x] [a f x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 4426, :end-line 4426, :max-fixed-arity 4, :fn-var true, :arglists ([a f] [a f x] [a f x y] [a f x y & more]), :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in."}, vals {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8692, :column 7, :end-line 8692, :end-column 11, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's values."}, :name cljs.core/vals, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([hash-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8692, :end-line 8692, :max-fixed-arity 1, :fn-var true, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's values."}, -chunked-next {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 824, :column 4, :end-line 824, :end-column 17, :protocol cljs.core/IChunkedNext, :doc "Returns a new collection of coll without the first chunk.", :arglists (quote ([coll]))}, :protocol cljs.core/IChunkedNext, :name cljs.core/-chunked-next, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 822, :end-line 824, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new collection of coll without the first chunk."}, Single {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/Single, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 4025, :record false, :end-line 4025, :skip-protocol-flag nil}, unchecked-subtract {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2745, :column 15, :end-line 2745, :end-column 33, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/unchecked-subtract, :variadic true, :file "cljs/core.cljs", :end-column 33, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2745, :ret-tag number, :end-line 2745, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result."}, remove-pair {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6797, :column 8, :end-line 6797, :end-column 19, :private true, :arglists (quote ([arr i]))}, :private true, :name cljs.core/remove-pair, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6797, :end-line 6797, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i]))}, IMap {:meta {:file "cljs/core.cljs", :line 626, :column 14, :end-line 626, :end-column 18, :doc "Protocol for adding mapping functionality to collections.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-dissoc [[coll k]]}}}, :protocol-symbol true, :name cljs.core/IMap, :file "cljs/core.cljs", :end-column 18, :column 1, :line 626, :protocol-info {:methods {-dissoc [[coll k]]}}, :info nil, :end-line 626, :tag any, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/PersistentTreeMap}, :doc "Protocol for adding mapping functionality to collections.", :jsdoc ("@interface")}, ->SeqIter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3981, :column 10, :end-line 3981, :end-column 17, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([_seq _next]))}, :protocols #{cljs.core/Object}, :name cljs.core/->SeqIter, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([_seq _next]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3981, :end-line 3981, :max-fixed-arity 2, :fn-var true, :arglists (quote ([_seq _next])), :skip-protocol-flag nil}, sorted-set-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9039, :column 7, :end-line 9039, :end-column 20, :arglists (quote ([comparator & keys])), :doc "Returns a new sorted set with supplied keys, using the supplied comparator.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keys)], :arglists ([comparator & keys]), :arglists-meta (nil)}}, :name cljs.core/sorted-set-by, :variadic true, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keys)], :arglists ([comparator & keys]), :arglists-meta (nil)}, :method-params [(comparator keys)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9039, :end-line 9039, :max-fixed-arity 1, :fn-var true, :arglists ([comparator & keys]), :doc "Returns a new sorted set with supplied keys, using the supplied comparator."}, PersistentVector {:num-fields 6, :protocols #{cljs.core/APersistentVector cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/PersistentVector, :file "cljs/core.cljs", :end-column 26, :type true, :column 10, :line 5178, :record false, :end-line 5178, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, cloneable? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1185, :column 16, :end-line 1185, :end-column 26, :tag boolean, :arglists (quote ([value])), :doc "Return true if x implements ICloneable protocol."}, :name cljs.core/cloneable?, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1185, :ret-tag boolean, :end-line 1185, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([value])), :doc "Return true if x implements ICloneable protocol."}, qualified-ident? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3327, :column 16, :end-line 3327, :end-column 32, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a symbol or keyword with a namespace"}, :name cljs.core/qualified-ident?, :variadic false, :file "cljs/core.cljs", :end-column 32, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3327, :ret-tag boolean, :end-line 3327, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a symbol or keyword with a namespace"}, hash-string* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 947, :column 7, :end-line 947, :end-column 19, :arglists (quote ([s]))}, :name cljs.core/hash-string*, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 947, :end-line 947, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, key-test {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6779, :column 16, :end-line 6779, :end-column 24, :tag boolean, :arglists (quote ([key other]))}, :name cljs.core/key-test, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([key other]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6779, :ret-tag boolean, :end-line 6779, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([key other]))}, -reset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10506, :column 4, :end-line 10506, :end-column 10, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-reset, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10505, :end-line 10506, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, true? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2186, :column 16, :end-line 2186, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is the value true, false otherwise."}, :name cljs.core/true?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2186, :ret-tag boolean, :end-line 2186, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is the value true, false otherwise."}, find-ns-obj* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11051, :column 8, :end-line 11051, :end-column 20, :private true, :arglists (quote ([ctxt xs])), :doc "Bootstrap only."}, :private true, :name cljs.core/find-ns-obj*, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([ctxt xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 11051, :end-line 11051, :max-fixed-arity 2, :fn-var true, :arglists (quote ([ctxt xs])), :doc "Bootstrap only."}, array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 423, :column 14, :end-line 423, :end-column 19, :tag array, :arglists (quote ([var-args])), :doc "Creates a new javascript array.\n@param {...*} var_args"}, :name cljs.core/array, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([var-args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 423, :ret-tag array, :end-line 423, :max-fixed-arity 1, :tag array, :fn-var true, :arglists (quote ([var-args])), :doc "Creates a new javascript array.\n@param {...*} var_args"}, print {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9770, :column 3, :end-line 9770, :end-column 8, :doc "Prints the object(s) using string-print.\n  print and println produce output for human consumption."}, :name cljs.core/print, :variadic true, :file "cljs/core.cljs", :end-column 8, :method-params ([objs]), :protocol-impl nil, :arglists-meta (), :column 1, :line 9767, :end-line 9770, :max-fixed-arity 0, :fn-var true, :arglists nil, :doc "Prints the object(s) using string-print.\n  print and println produce output for human consumption."}, -peek {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 648, :column 4, :end-line 648, :end-column 9, :protocol cljs.core/IStack, :doc "Returns the item from the top of the stack. Is used by cljs.core/peek.", :arglists (quote ([coll]))}, :protocol cljs.core/IStack, :name cljs.core/-peek, :variadic false, :file "cljs/core.cljs", :end-column 9, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 644, :end-line 648, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the item from the top of the stack. Is used by cljs.core/peek."}, ISeq {:meta {:file "cljs/core.cljs", :line 589, :column 14, :end-line 589, :end-column 18, :doc "Protocol for collections to provide access to their items as sequences.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-first [[coll]], -rest [[coll]]}}}, :protocol-symbol true, :name cljs.core/ISeq, :file "cljs/core.cljs", :end-column 18, :column 1, :line 589, :protocol-info {:methods {-first [[coll]], -rest [[coll]]}}, :info nil, :end-line 589, :tag any, :impls #{cljs.core/Cons cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/LazySeq cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/Range cljs.core/PersistentTreeMapSeq}, :doc "Protocol for collections to provide access to their items as sequences.", :jsdoc ("@interface")}, empty {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1776, :column 7, :end-line 1776, :end-column 12, :arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll, or nil"}, :name cljs.core/empty, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1776, :end-line 1776, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll, or nil"}, remove-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10709, :column 7, :end-line 10709, :end-column 20, :arglists (quote ([multifn dispatch-val])), :doc "Removes the method of multimethod associated with dispatch-value."}, :name cljs.core/remove-method, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([multifn dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10709, :end-line 10709, :max-fixed-arity 2, :fn-var true, :arglists (quote ([multifn dispatch-val])), :doc "Removes the method of multimethod associated with dispatch-value."}, PersistentQueueSeq {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/PersistentQueueSeq, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 5872, :record false, :end-line 5872, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}}, balance-right-del {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7925, :column 8, :end-line 7925, :end-column 25, :private true, :arglists (quote ([key val left del]))}, :private true, :name cljs.core/balance-right-del, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([key val left del]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7925, :end-line 7925, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val left del]))}, volatile! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4483, :column 7, :end-line 4483, :end-column 16, :arglists (quote ([val])), :doc "Creates and returns a Volatile with an initial value of val."}, :name cljs.core/volatile!, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4483, :end-line 4483, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :doc "Creates and returns a Volatile with an initial value of val."}, / {:protocol-inline nil, :meta {:tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :file "cljs/core.cljs"}, :name cljs.core//, :variadic true, :file "cljs/core.cljs", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2590, :ret-tag number, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators."}, bitpos {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6806, :column 8, :end-line 6806, :end-column 14, :private true, :arglists (quote ([hash shift]))}, :private true, :name cljs.core/bitpos, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([hash shift]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6806, :end-line 6806, :max-fixed-arity 2, :fn-var true, :arglists (quote ([hash shift]))}, Many {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/Many, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 4011, :record false, :end-line 4011, :skip-protocol-flag nil}, bit-or {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2827, :column 7, :end-line 2827, :end-column 13, :arglists (quote ([x y] [x y & more])), :doc "Bitwise or", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}}, :name cljs.core/bit-or, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2827, :end-line 2827, :max-fixed-arity 2, :fn-var true, :arglists ([x y] [x y & more]), :doc "Bitwise or"}, m3-fmix {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 908, :column 15, :end-line 908, :end-column 22, :tag number, :arglists (quote ([h1 len]))}, :name cljs.core/m3-fmix, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([h1 len]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 908, :ret-tag number, :end-line 908, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([h1 len]))}, vector {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5409, :column 7, :end-line 5409, :end-column 13, :arglists (quote ([& args])), :doc "Creates a new vector containing the args.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}}, :name cljs.core/vector, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}, :method-params [(args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 5409, :end-line 5409, :max-fixed-arity 0, :fn-var true, :arglists ([& args]), :doc "Creates a new vector containing the args."}, hash-coll {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2961, :column 8, :end-line 2961, :end-column 17, :private true, :arglists (quote ([coll]))}, :private true, :name cljs.core/hash-coll, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2961, :end-line 2961, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, clone-and-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6788, :column 8, :end-line 6788, :end-column 21, :private true, :arglists (quote ([arr i a] [arr i a j b])), :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([arr i a] [arr i a j b]), :arglists ([arr i a] [arr i a j b]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/clone-and-set, :variadic false, :file "cljs/core.cljs", :end-column 21, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([arr i a] [arr i a j b]), :arglists ([arr i a] [arr i a j b]), :arglists-meta (nil nil)}, :method-params ([arr i a] [arr i a j b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6788, :end-line 6788, :max-fixed-arity 5, :fn-var true, :arglists ([arr i a] [arr i a j b])}, array->transient-hash-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6766, :column 8, :end-line 6766, :end-column 33, :private true, :arglists (quote ([len arr]))}, :private true, :name cljs.core/array->transient-hash-map, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([len arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6766, :end-line 6766, :max-fixed-arity 2, :fn-var true, :arglists (quote ([len arr]))}, >= {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2633, :column 16, :end-line 2633, :end-column 18, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/>=, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2633, :ret-tag boolean, :end-line 2633, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false."}, ->TransientHashSet {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8873, :column 10, :end-line 8873, :end-column 26, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :factory :positional, :arglists (quote ([transient-map]))}, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name cljs.core/->TransientHashSet, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([transient-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 8873, :end-line 8873, :max-fixed-arity 1, :fn-var true, :arglists (quote ([transient-map])), :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}}, drop-last {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4710, :column 7, :end-line 4710, :end-column 16, :arglists (quote ([s] [n s])), :doc "Return a lazy sequence of all but the last n (default 1) items in coll", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([s] [n s]), :arglists ([s] [n s]), :arglists-meta (nil nil)}}, :name cljs.core/drop-last, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([s] [n s]), :arglists ([s] [n s]), :arglists-meta (nil nil)}, :method-params ([s] [n s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4710, :end-line 4710, :max-fixed-arity 2, :fn-var true, :arglists ([s] [n s]), :doc "Return a lazy sequence of all but the last n (default 1) items in coll"}, ->ArrayIter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3966, :column 10, :end-line 3966, :end-column 19, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([arr i]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayIter, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3966, :end-line 3966, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag nil}, object? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 246, :column 16, :end-line 246, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x's constructor is Object"}, :name cljs.core/object?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 246, :ret-tag boolean, :end-line 246, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x's constructor is Object"}, ->ArrayNodeSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7419, :column 10, :end-line 7419, :end-column 22, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta nodes i s __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ArrayNodeSeq, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([meta nodes i s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7419, :end-line 7419, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta nodes i s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, lift-ns {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9804, :column 8, :end-line 9804, :end-column 15, :private true, :arglists (quote ([m])), :doc "Returns [lifted-ns lifted-map] or nil if m can't be lifted."}, :private true, :name cljs.core/lift-ns, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9804, :end-line 9804, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns [lifted-ns lifted-map] or nil if m can't be lifted."}, tree-map-append {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8259, :column 8, :end-line 8259, :end-column 23, :private true, :arglists (quote ([left right]))}, :private true, :name cljs.core/tree-map-append, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([left right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8259, :end-line 8259, :max-fixed-arity 2, :fn-var true, :arglists (quote ([left right]))}, not-empty {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3943, :column 7, :end-line 3943, :end-column 16, :arglists (quote ([coll])), :doc "If coll is empty, returns nil, else coll"}, :name cljs.core/not-empty, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3943, :end-line 3943, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "If coll is empty, returns nil, else coll"}, distinct {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9063, :column 7, :end-line 9063, :end-column 15, :arglists (quote ([] [coll])), :doc "Returns a lazy sequence of the elements of coll with duplicates removed.\n  Returns a stateful transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}}, :name cljs.core/distinct, :variadic false, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}, :method-params ([] [coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9063, :end-line 9063, :max-fixed-arity 1, :fn-var true, :arglists ([] [coll]), :doc "Returns a lazy sequence of the elements of coll with duplicates removed.\n  Returns a stateful transducer when no collection is provided."}, partition {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4945, :column 7, :end-line 4945, :end-column 16, :arglists (quote ([n coll] [n step coll] [n step pad coll])), :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([n coll] [n step coll] [n step pad coll]), :arglists ([n coll] [n step coll] [n step pad coll]), :arglists-meta (nil nil nil)}}, :name cljs.core/partition, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([n coll] [n step coll] [n step pad coll]), :arglists ([n coll] [n step coll] [n step pad coll]), :arglists-meta (nil nil nil)}, :method-params ([n coll] [n step coll] [n step pad coll]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 4945, :end-line 4945, :max-fixed-arity 4, :fn-var true, :arglists ([n coll] [n step coll] [n step pad coll]), :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items."}, IMultiFn {:meta {:file "cljs/core.cljs", :line 10505, :column 14, :end-line 10505, :end-column 22, :doc nil, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-prefer-method [[mf dispatch-val dispatch-val-y]], -default-dispatch-val [[mf]], -remove-method [[mf dispatch-val]], -methods [[mf]], -prefers [[mf]], -dispatch-fn [[mf]], -add-method [[mf dispatch-val method]], -reset [[mf]], -get-method [[mf dispatch-val]]}}}, :protocol-symbol true, :name cljs.core/IMultiFn, :file "cljs/core.cljs", :end-column 22, :column 1, :line 10505, :protocol-info {:methods {-prefer-method [[mf dispatch-val dispatch-val-y]], -default-dispatch-val [[mf]], -remove-method [[mf dispatch-val]], -methods [[mf]], -prefers [[mf]], -dispatch-fn [[mf]], -add-method [[mf dispatch-val method]], -reset [[mf]], -get-method [[mf dispatch-val]]}}, :info nil, :end-line 10505, :tag any, :impls #{cljs.core/MultiFn}, :doc nil, :jsdoc ("@interface")}, ->Many {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4011, :column 10, :end-line 4011, :end-column 14, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([vals]))}, :protocols #{cljs.core/Object}, :name cljs.core/->Many, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([vals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 4011, :end-line 4011, :max-fixed-arity 1, :fn-var true, :arglists (quote ([vals])), :skip-protocol-flag nil}, DEMUNGE_PATTERN {:name cljs.core/DEMUNGE_PATTERN, :file "cljs/core.cljs", :line 377, :column 1, :end-line 377, :end-column 21, :meta {:file "cljs/core.cljs", :line 377, :column 6, :end-line 377, :end-column 21}, :tag clj-nil}, fix {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2759, :column 16, :end-line 2759, :end-column 19, :tag number, :private true, :arglists (quote ([q]))}, :private true, :name cljs.core/fix, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([q]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2759, :ret-tag number, :end-line 2759, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([q]))}, EmptyList {:num-fields 1, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/EmptyList, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 3078, :record false, :end-line 3078, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, HashMapIter {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/HashMapIter, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 7486, :record false, :end-line 7486, :skip-protocol-flag nil}, IAssociative {:meta {:file "cljs/core.cljs", :line 613, :column 14, :end-line 613, :end-column 26, :doc "Protocol for adding associativity to collections.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-contains-key? [[coll k]], -assoc [[coll k v]]}}}, :protocol-symbol true, :name cljs.core/IAssociative, :file "cljs/core.cljs", :end-column 26, :column 1, :line 613, :protocol-info {:methods {-contains-key? [[coll k]], -assoc [[coll k v]]}}, :info nil, :end-line 613, :tag any, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/BlackNode cljs.core/MapEntry cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap cljs.core/RedNode}, :doc "Protocol for adding associativity to collections.", :jsdoc ("@interface")}, ->Single {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4025, :column 10, :end-line 4025, :end-column 16, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([val]))}, :protocols #{cljs.core/Object}, :name cljs.core/->Single, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 4025, :end-line 4025, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :skip-protocol-flag nil}, bit-flip {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2844, :column 7, :end-line 2844, :end-column 15, :arglists (quote ([x n])), :doc "Flip bit at index n"}, :name cljs.core/bit-flip, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2844, :end-line 2844, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Flip bit at index n"}, long-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3639, :column 7, :end-line 3639, :end-column 17, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}}, :name cljs.core/long-array, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3639, :end-line 3639, :max-fixed-arity 2, :fn-var true, :arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure."}, descendants {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10386, :column 7, :end-line 10386, :end-column 18, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}}, :name cljs.core/descendants, :variadic false, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}, :method-params ([tag] [h tag]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10386, :end-line 10386, :max-fixed-arity 2, :fn-var true, :arglists ([tag] [h tag]), :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships."}, imul {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 887, :column 17, :end-line 887, :end-column 21, :tag number, :arglists (quote ([a b]))}, :name cljs.core/imul, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 3, :line 887, :ret-tag number, :end-line 887, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([a b]))}, ->Delay {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10058, :column 10, :end-line 10058, :end-column 15, :protocols #{cljs.core/IPending cljs.core/IDeref}, :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref}, :factory :positional, :arglists (quote ([f value]))}, :protocols #{cljs.core/IPending cljs.core/IDeref}, :name cljs.core/->Delay, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([f value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 10058, :end-line 10058, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f value])), :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref}}, array-for {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5108, :column 8, :end-line 5108, :end-column 17, :private true, :arglists (quote ([pv i]))}, :private true, :name cljs.core/array-for, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pv i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5108, :end-line 5108, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pv i]))}, merge {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8703, :column 7, :end-line 8703, :end-column 12, :arglists (quote ([& maps])), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(maps)], :arglists ([& maps]), :arglists-meta (nil)}}, :name cljs.core/merge, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(maps)], :arglists ([& maps]), :arglists-meta (nil)}, :method-params [(maps)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8703, :end-line 8703, :max-fixed-arity 0, :fn-var true, :arglists ([& maps]), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result."}, ISeqable {:meta {:file "cljs/core.cljs", :line 702, :column 14, :end-line 702, :end-column 22, :doc "Protocol for adding the ability to a type to be transformed into a sequence.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-seq [[o]]}}}, :protocol-symbol true, :name cljs.core/ISeqable, :file "cljs/core.cljs", :end-column 22, :column 1, :line 702, :protocol-info {:methods {-seq [[o]]}}, :info nil, :end-line 702, :tag any, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding the ability to a type to be transformed into a sequence.", :jsdoc ("@interface")}, Empty {:num-fields 0, :protocols #{cljs.core/Object}, :name cljs.core/Empty, :file "cljs/core.cljs", :end-column 15, :type true, :column 10, :line 4044, :record false, :end-line 4044, :skip-protocol-flag nil}, js-mod {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2793, :column 7, :end-line 2793, :end-column 13, :arglists (quote ([n d])), :doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers"}, :name cljs.core/js-mod, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2793, :end-line 2793, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers"}, integer? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2227, :column 16, :end-line 2227, :end-column 24, :tag boolean, :arglists (quote ([n])), :doc "Returns true if n is a JavaScript number with no decimal part."}, :name cljs.core/integer?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2227, :ret-tag boolean, :end-line 2227, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is a JavaScript number with no decimal part."}, MetaFn {:num-fields 2, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :name cljs.core/MetaFn, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 1981, :record false, :end-line 1981, :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}}, NS_CACHE {:meta {:file "cljs/core.cljs", :line 11049, :column 3, :end-line 11049, :end-column 11, :doc "Bootstrap only.", :jsdoc ["@type {*}"]}, :name cljs.core/NS_CACHE, :file "cljs/core.cljs", :end-column 11, :column 1, :line 11047, :end-line 11049, :tag clj-nil, :doc "Bootstrap only.", :jsdoc ["@type {*}"]}, mapv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4920, :column 7, :end-line 4920, :end-column 11, :arglists (quote ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f coll] [f c1 c2] [f c1 c2 c3]), :arglists ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/mapv, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f coll] [f c1 c2] [f c1 c2 c3]), :arglists ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :arglists-meta (nil nil nil nil)}, :method-params ([f coll] [f c1 c2] [f c1 c2 c3]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 4920, :end-line 4920, :max-fixed-arity 4, :fn-var true, :arglists ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments."}, infinite? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2298, :column 16, :end-line 2298, :end-column 25, :tag boolean, :arglists (quote ([x])), :doc "Returns true for Infinity and -Infinity values."}, :name cljs.core/infinite?, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2298, :ret-tag boolean, :end-line 2298, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true for Infinity and -Infinity values."}, partition-all {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9143, :column 7, :end-line 9143, :end-column 20, :arglists (quote ([n] [n coll] [n step coll])), :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([n] [n coll] [n step coll]), :arglists ([n] [n coll] [n step coll]), :arglists-meta (nil nil nil)}}, :name cljs.core/partition-all, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([n] [n coll] [n step coll]), :arglists ([n] [n coll] [n step coll]), :arglists-meta (nil nil nil)}, :method-params ([n] [n coll] [n step coll]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 9143, :end-line 9143, :max-fixed-arity 3, :fn-var true, :arglists ([n] [n coll] [n step coll]), :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided."}, partition-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9372, :column 7, :end-line 9372, :end-column 19, :arglists (quote ([f] [f coll])), :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name cljs.core/partition-by, :variadic false, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9372, :end-line 9372, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided."}, ISequential {:meta {:file "cljs/core.cljs", :line 707, :column 14, :end-line 707, :end-column 25, :doc "Marker interface indicating a persistent collection of sequential items", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/ISequential, :file "cljs/core.cljs", :end-column 25, :column 1, :line 707, :protocol-info {:methods {}}, :info nil, :end-line 707, :tag any, :impls #{cljs.core/Cons cljs.core/Eduction cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Marker interface indicating a persistent collection of sequential items", :jsdoc ("@interface")}, ->LazySeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3371, :column 10, :end-line 3371, :end-column 17, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta fn s __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->LazySeq, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([meta fn s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3371, :end-line 3371, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta fn s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, equiv-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6006, :column 16, :end-line 6006, :end-column 25, :tag boolean, :arglists (quote ([x y])), :doc "Test map equivalence. Returns true if x equals y, otherwise returns false."}, :name cljs.core/equiv-map, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6006, :ret-tag boolean, :end-line 6006, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x y])), :doc "Test map equivalence. Returns true if x equals y, otherwise returns false."}, ->Volatile {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4475, :column 10, :end-line 4475, :end-column 18, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :skip-protocol-flag #{cljs.core/IDeref}, :factory :positional, :arglists (quote ([state]))}, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :name cljs.core/->Volatile, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([state]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 4475, :end-line 4475, :max-fixed-arity 1, :fn-var true, :arglists (quote ([state])), :skip-protocol-flag #{cljs.core/IDeref}}, object-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3683, :column 7, :end-line 3683, :end-column 19, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}}, :name cljs.core/object-array, :variadic false, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3683, :end-line 3683, :max-fixed-arity 2, :fn-var true, :arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure."}, Keyword {:meta {:file "cljs/core.cljs", :line 210, :column 20, :end-line 210, :end-column 27, :declared true}, :num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :name cljs.core/Keyword, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 3261, :record false, :declared true, :end-line 3261, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}}, derive {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10395, :column 7, :end-line 10395, :end-column 13, :arglists (quote ([tag parent] [h tag parent])), :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([tag parent] [h tag parent]), :arglists ([tag parent] [h tag parent]), :arglists-meta (nil nil)}}, :name cljs.core/derive, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([tag parent] [h tag parent]), :arglists ([tag parent] [h tag parent]), :arglists-meta (nil nil)}, :method-params ([tag parent] [h tag parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10395, :end-line 10395, :max-fixed-arity 3, :fn-var true, :arglists ([tag parent] [h tag parent]), :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy."}, seq-iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3999, :column 7, :end-line 3999, :end-column 15, :arglists (quote ([coll]))}, :name cljs.core/seq-iter, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3999, :end-line 3999, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, ->Empty {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4044, :column 10, :end-line 4044, :end-column 15, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([]))}, :protocols #{cljs.core/Object}, :name cljs.core/->Empty, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 4044, :end-line 4044, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :skip-protocol-flag nil}, IChunkedSeq {:meta {:file "cljs/core.cljs", :line 815, :column 14, :end-line 815, :end-column 25, :doc "Protocol for accessing a collection as sequential chunks.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-chunked-first [[coll]], -chunked-rest [[coll]]}}}, :protocol-symbol true, :name cljs.core/IChunkedSeq, :file "cljs/core.cljs", :end-column 25, :column 1, :line 815, :protocol-info {:methods {-chunked-first [[coll]], -chunked-rest [[coll]]}}, :info nil, :end-line 815, :tag any, :impls #{cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :doc "Protocol for accessing a collection as sequential chunks.", :jsdoc ("@interface")}, special-symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10867, :column 16, :end-line 10867, :end-column 31, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x names a special form"}, :name cljs.core/special-symbol?, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10867, :ret-tag boolean, :end-line 10867, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x names a special form"}, compare-keywords {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3249, :column 8, :end-line 3249, :end-column 24, :private true, :arglists (quote ([a b]))}, :private true, :name cljs.core/compare-keywords, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3249, :end-line 3249, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, ancestors {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10378, :column 7, :end-line 10378, :end-column 16, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}}, :name cljs.core/ancestors, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}, :method-params ([tag] [h tag]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10378, :end-line 10378, :max-fixed-arity 2, :fn-var true, :arglists ([tag] [h tag]), :doc "Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy"}, subseq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9199, :column 7, :end-line 9199, :end-column 13, :arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :arglists ([sc test key] [sc start-test start-key end-test end-key]), :arglists-meta (nil nil)}}, :name cljs.core/subseq, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :arglists ([sc test key] [sc start-test start-key end-test end-key]), :arglists-meta (nil nil)}, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9199, :end-line 9199, :max-fixed-arity 5, :fn-var true, :arglists ([sc test key] [sc start-test start-key end-test end-key]), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true"}, gensym {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10041, :column 7, :end-line 10041, :end-column 13, :arglists (quote ([] [prefix-string])), :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [prefix-string]), :arglists ([] [prefix-string]), :arglists-meta (nil nil)}}, :name cljs.core/gensym, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [prefix-string]), :arglists ([] [prefix-string]), :arglists-meta (nil nil)}, :method-params ([] [prefix-string]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10041, :end-line 10041, :max-fixed-arity 1, :fn-var true, :arglists ([] [prefix-string]), :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'."}, -next {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 601, :column 16, :end-line 601, :end-column 21, :tag clj-or-nil, :protocol cljs.core/INext, :doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil", :arglists (quote ([coll]))}, :protocol cljs.core/INext, :name cljs.core/-next, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 599, :ret-tag clj-or-nil, :end-line 601, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil"}, ->HashCollisionNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7221, :column 10, :end-line 7221, :end-column 27, :protocols #{cljs.core/Object cljs.core/IIterable}, :skip-protocol-flag #{cljs.core/IIterable}, :factory :positional, :arglists (quote ([edit collision-hash cnt arr]))}, :protocols #{cljs.core/Object cljs.core/IIterable}, :name cljs.core/->HashCollisionNode, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([edit collision-hash cnt arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7221, :end-line 7221, :max-fixed-arity 4, :fn-var true, :arglists (quote ([edit collision-hash cnt arr])), :skip-protocol-flag #{cljs.core/IIterable}}, delay? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10070, :column 16, :end-line 10070, :end-column 22, :tag boolean, :arglists (quote ([x])), :doc "returns true if x is a Delay created with delay"}, :name cljs.core/delay?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10070, :ret-tag boolean, :end-line 10070, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "returns true if x is a Delay created with delay"}, create-inode-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7402, :column 8, :end-line 7402, :end-column 24, :private true, :arglists (quote ([nodes] [nodes i s])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([nodes] [nodes i s]), :arglists ([nodes] [nodes i s]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/create-inode-seq, :variadic false, :file "cljs/core.cljs", :end-column 24, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([nodes] [nodes i s]), :arglists ([nodes] [nodes i s]), :arglists-meta (nil nil)}, :method-params ([nodes] [nodes i s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7402, :end-line 7402, :max-fixed-arity 3, :fn-var true, :arglists ([nodes] [nodes i s])}, flatten {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4896, :column 7, :end-line 4896, :end-column 14, :arglists (quote ([x])), :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil."}, :name cljs.core/flatten, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4896, :end-line 4896, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil."}, -dissoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 629, :column 9, :end-line 629, :end-column 16, :tag clj, :protocol cljs.core/IMap, :doc "Returns a new collection of coll without the mapping for key k.", :arglists (quote ([coll k]))}, :protocol cljs.core/IMap, :name cljs.core/-dissoc, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 626, :ret-tag clj, :end-line 629, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll k])), :doc "Returns a new collection of coll without the mapping for key k."}, doubles {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2790, :column 7, :end-line 2790, :end-column 14, :arglists (quote ([x]))}, :name cljs.core/doubles, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2790, :end-line 2790, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, halt-when {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10105, :column 7, :end-line 10105, :end-column 16, :arglists (quote ([pred] [pred retf])), :doc "Returns a transducer that ends transduction when pred returns true\n  for an input. When retf is supplied it must be a fn of 2 arguments -\n  it will be passed the (completed) result so far and the input that\n  triggered the predicate, and its return value (if it does not throw\n  an exception) will be the return value of the transducer. If retf\n  is not supplied, the input that triggered the predicate will be\n  returned. If the predicate never returns true the transduction is\n  unaffected.", :added "1.9", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred retf]), :arglists ([pred] [pred retf]), :arglists-meta (nil nil)}}, :added "1.9", :name cljs.core/halt-when, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred retf]), :arglists ([pred] [pred retf]), :arglists-meta (nil nil)}, :method-params ([pred] [pred retf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10105, :end-line 10105, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred retf]), :doc "Returns a transducer that ends transduction when pred returns true\n  for an input. When retf is supplied it must be a fn of 2 arguments -\n  it will be passed the (completed) result so far and the input that\n  triggered the predicate, and its return value (if it does not throw\n  an exception) will be the return value of the transducer. If retf\n  is not supplied, the input that triggered the predicate will be\n  returned. If the predicate never returns true the transduction is\n  unaffected."}, -contains-key? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 615, :column 13, :end-line 615, :end-column 27, :tag boolean, :protocol cljs.core/IAssociative, :doc "Returns true if k is a key in coll.", :arglists (quote ([coll k]))}, :protocol cljs.core/IAssociative, :name cljs.core/-contains-key?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 613, :ret-tag boolean, :end-line 615, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([coll k])), :doc "Returns true if k is a key in coll."}, remove-watch {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10029, :column 7, :end-line 10029, :end-column 19, :arglists (quote ([iref key])), :doc "Removes a watch (set by add-watch) from a reference"}, :name cljs.core/remove-watch, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([iref key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10029, :end-line 10029, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref key])), :doc "Removes a watch (set by add-watch) from a reference"}, ex-info {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10832, :column 7, :end-line 10832, :end-column 14, :arglists (quote ([msg data] [msg data cause])), :doc "Create an instance of ExceptionInfo, an Error type that carries a\n  map of additional data.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([msg data] [msg data cause]), :arglists ([msg data] [msg data cause]), :arglists-meta (nil nil)}}, :name cljs.core/ex-info, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([msg data] [msg data cause]), :arglists ([msg data] [msg data cause]), :arglists-meta (nil nil)}, :method-params ([msg data] [msg data cause]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10832, :end-line 10832, :max-fixed-arity 3, :fn-var true, :arglists ([msg data] [msg data cause]), :doc "Create an instance of ExceptionInfo, an Error type that carries a\n  map of additional data."}, ifn? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2222, :column 16, :end-line 2222, :end-column 20, :tag boolean, :arglists (quote ([f])), :doc "Returns true if f returns true for fn? or satisfies IFn."}, :name cljs.core/ifn?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2222, :ret-tag boolean, :end-line 2222, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :doc "Returns true if f returns true for fn? or satisfies IFn."}, IAtom {:meta {:file "cljs/core.cljs", :line 834, :column 14, :end-line 834, :end-column 19, :doc "Marker protocol indicating an atom.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/IAtom, :file "cljs/core.cljs", :end-column 19, :column 1, :line 834, :protocol-info {:methods {}}, :info nil, :end-line 834, :tag any, :impls #{cljs.core/Atom}, :doc "Marker protocol indicating an atom.", :jsdoc ("@interface")}, ->PersistentQueue {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5927, :column 10, :end-line 5927, :end-column 25, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([meta count front rear __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->PersistentQueue, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([meta count front rear __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5927, :end-line 5927, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta count front rear __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta}}, nat-int? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2273, :column 16, :end-line 2273, :end-column 24, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies int? and is a natural integer value."}, :name cljs.core/nat-int?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2273, :ret-tag boolean, :end-line 2273, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies int? and is a natural integer value."}, IWatchable {:meta {:file "cljs/core.cljs", :line 759, :column 14, :end-line 759, :end-column 24, :doc "Protocol for types that can be watched. Currently only implemented by Atom.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-notify-watches [[this oldval newval]], -add-watch [[this key f]], -remove-watch [[this key]]}}}, :protocol-symbol true, :name cljs.core/IWatchable, :file "cljs/core.cljs", :end-column 24, :column 1, :line 759, :protocol-info {:methods {-notify-watches [[this oldval newval]], -add-watch [[this key f]], -remove-watch [[this key]]}}, :info nil, :end-line 759, :tag any, :impls #{cljs.core/Atom}, :doc "Protocol for types that can be watched. Currently only implemented by Atom.", :jsdoc ("@interface")}, pv-fresh-node {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5042, :column 8, :end-line 5042, :end-column 21, :private true, :arglists (quote ([edit]))}, :private true, :name cljs.core/pv-fresh-node, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([edit]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5042, :end-line 5042, :max-fixed-arity 1, :fn-var true, :arglists (quote ([edit]))}, subvec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5657, :column 7, :end-line 5657, :end-column 13, :arglists (quote ([v start] [v start end])), :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([v start] [v start end]), :arglists ([v start] [v start end]), :arglists-meta (nil nil)}}, :name cljs.core/subvec, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([v start] [v start end]), :arglists ([v start] [v start end]), :arglists-meta (nil nil)}, :method-params ([v start] [v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5657, :end-line 5657, :max-fixed-arity 3, :fn-var true, :arglists ([v start] [v start end]), :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done."}, -pop! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 796, :column 9, :end-line 796, :end-column 14, :tag clj, :protocol cljs.core/ITransientVector, :doc "Returns tcoll with the last item removed from it.", :arglists (quote ([tcoll]))}, :protocol cljs.core/ITransientVector, :name cljs.core/-pop!, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 792, :ret-tag clj, :end-line 796, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([tcoll])), :doc "Returns tcoll with the last item removed from it."}, partial {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4246, :column 7, :end-line 4246, :end-column 14, :arglists (quote ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more])), :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3]), :arglists ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/partial, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3]), :arglists ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]), :arglists-meta (nil nil nil nil nil)}, :method-params ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 4246, :end-line 4246, :max-fixed-arity 4, :fn-var true, :arglists ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]), :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args."}, chunked-seq? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2137, :column 16, :end-line 2137, :end-column 28, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is satisfies IChunkedSeq."}, :name cljs.core/chunked-seq?, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2137, :ret-tag boolean, :end-line 2137, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is satisfies IChunkedSeq."}, replicate {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4765, :column 7, :end-line 4765, :end-column 16, :arglists (quote ([n x])), :doc "DEPRECATED: Use 'repeat' instead.\n  Returns a lazy seq of n xs."}, :name cljs.core/replicate, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([n x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4765, :end-line 4765, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n x])), :doc "DEPRECATED: Use 'repeat' instead.\n  Returns a lazy seq of n xs."}, PersistentQueue {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/PersistentQueue, :file "cljs/core.cljs", :end-column 25, :type true, :column 10, :line 5927, :record false, :end-line 5927, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta}}, min-key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9125, :column 7, :end-line 9125, :end-column 14, :arglists (quote ([k x] [k x y] [k x y & more])), :doc "Returns the x for which (k x), a number, is least.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([k x] [k x y]), :arglists ([k x] [k x y] [k x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/min-key, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([k x] [k x y]), :arglists ([k x] [k x y] [k x y & more]), :arglists-meta (nil nil nil)}, :method-params ([k x] [k x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 9125, :end-line 9125, :max-fixed-arity 3, :fn-var true, :arglists ([k x] [k x y] [k x y & more]), :doc "Returns the x for which (k x), a number, is least."}, hash-iset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2981, :column 8, :end-line 2981, :end-column 17, :private true, :arglists (quote ([s]))}, :private true, :name cljs.core/hash-iset, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2981, :end-line 2981, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, reduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1409, :column 7, :end-line 1409, :end-column 14, :arglists (quote ([x])), :doc "Wraps x in a way such that a reduce will terminate with the value x"}, :name cljs.core/reduced, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1409, :end-line 1409, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Wraps x in a way such that a reduce will terminate with the value x"}, re-matches {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9508, :column 7, :end-line 9508, :end-column 17, :arglists (quote ([re s])), :doc "Returns the result of (re-find re s) if re fully matches s."}, :name cljs.core/re-matches, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9508, :end-line 9508, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns the result of (re-find re s) if re fully matches s."}, pr-writer-impl {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9614, :column 8, :end-line 9614, :end-column 22, :private true, :arglists (quote ([obj writer opts]))}, :private true, :name cljs.core/pr-writer-impl, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([obj writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9614, :end-line 9614, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts]))}, array-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8510, :column 7, :end-line 8510, :end-column 16, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new array map with supplied mappings.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name cljs.core/array-map, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8510, :end-line 8510, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new array map with supplied mappings."}, ITransientSet {:meta {:file "cljs/core.cljs", :line 799, :column 14, :end-line 799, :end-column 27, :doc "Protocol for adding set functionality to a transient collection.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-disjoin! [[tcoll v]]}}}, :protocol-symbol true, :name cljs.core/ITransientSet, :file "cljs/core.cljs", :end-column 27, :column 1, :line 799, :protocol-info {:methods {-disjoin! [[tcoll v]]}}, :info nil, :end-line 799, :tag any, :impls #{cljs.core/TransientHashSet}, :doc "Protocol for adding set functionality to a transient collection.", :jsdoc ("@interface")}, ITER_SYMBOL {:name cljs.core/ITER_SYMBOL, :file "cljs/core.cljs", :line 321, :column 3, :end-line 321, :end-column 19, :meta {:file "cljs/core.cljs", :line 321, :column 8, :end-line 321, :end-column 19}, :tag string}, unchecked-byte {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2677, :column 15, :end-line 2677, :end-column 29, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-byte, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2677, :ret-tag number, :end-line 2677, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, checked-aset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 454, :column 8, :end-line 454, :end-column 20, :private true, :arglists (quote ([array idx val] [array idx idx2 & idxv])), :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([array idx val]), :arglists ([array idx val] [array idx idx2 & idxv]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/checked-aset, :variadic true, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([array idx val]), :arglists ([array idx val] [array idx idx2 & idxv]), :arglists-meta (nil nil)}, :method-params ([array idx val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 454, :end-line 454, :max-fixed-arity 3, :fn-var true, :arglists ([array idx val] [array idx idx2 & idxv])}, ArrayNode {:meta {:file "cljs/core.cljs", :line 6836, :column 10, :end-line 6836, :end-column 19, :declared true}, :num-fields 3, :protocols #{cljs.core/Object cljs.core/IIterable}, :name cljs.core/ArrayNode, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 7111, :record false, :declared true, :end-line 7111, :skip-protocol-flag #{cljs.core/IIterable}}, ->ChunkedSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5418, :column 10, :end-line 5418, :end-column 20, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([vec node i off meta __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ChunkedSeq, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([vec node i off meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5418, :end-line 5418, :max-fixed-arity 6, :fn-var true, :arglists (quote ([vec node i off meta __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, every-pred {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4533, :column 7, :end-line 4533, :end-column 17, :arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([p] [p1 p2] [p1 p2 p3]), :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/every-pred, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([p] [p1 p2] [p1 p2 p3]), :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :arglists-meta (nil nil nil nil)}, :method-params ([p] [p1 p2] [p1 p2 p3]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 4533, :end-line 4533, :max-fixed-arity 3, :fn-var true, :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates."}, keys {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8616, :column 7, :end-line 8616, :end-column 11, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's keys."}, :name cljs.core/keys, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([hash-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8616, :end-line 8616, :max-fixed-arity 1, :fn-var true, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's keys."}, missing-protocol {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 299, :column 7, :end-line 299, :end-column 23, :arglists (quote ([proto obj]))}, :name cljs.core/missing-protocol, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([proto obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 299, :end-line 299, :max-fixed-arity 2, :fn-var true, :arglists (quote ([proto obj]))}, load-file {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 314, :column 7, :end-line 314, :end-column 16, :arglists (quote ([file]))}, :name cljs.core/load-file, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([file]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 314, :end-line 314, :max-fixed-arity 1, :fn-var true, :arglists (quote ([file]))}, PersistentArrayMap {:meta {:file "cljs/core.cljs", :line 1945, :column 28, :end-line 1945, :end-column 46, :declared true}, :num-fields 4, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/PersistentArrayMap, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 6476, :record false, :declared true, :end-line 6476, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}}, distinct? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2325, :column 16, :end-line 2325, :end-column 25, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns true if no two of the arguments are =", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/distinct?, :variadic true, :file "cljs/core.cljs", :end-column 25, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2325, :ret-tag boolean, :end-line 2325, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns true if no two of the arguments are ="}, pos-int? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2243, :column 16, :end-line 2243, :end-column 24, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies int? and is positive."}, :name cljs.core/pos-int?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2243, :ret-tag boolean, :end-line 2243, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies int? and is positive."}, never-equiv {:name cljs.core/never-equiv, :file "cljs/core.cljs", :line 6004, :column 1, :end-line 6004, :end-column 27, :private true, :meta {:file "cljs/core.cljs", :line 6004, :column 16, :end-line 6004, :end-column 27, :private true}, :tag cljs.core/NeverEquiv}, unchecked-short {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2679, :column 15, :end-line 2679, :end-column 30, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-short, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2679, :ret-tag number, :end-line 2679, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, ->Range {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9240, :column 10, :end-line 9240, :end-column 15, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta start end step __hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->Range, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([meta start end step __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 9240, :end-line 9240, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta start end step __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, ->MapEntry {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6306, :column 10, :end-line 6306, :end-column 18, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :factory :positional, :arglists (quote ([key val __hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->MapEntry, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([key val __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6306, :end-line 6306, :max-fixed-arity 3, :fn-var true, :arglists (quote ([key val __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, apply-to-simple {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3836, :column 8, :end-line 3836, :end-column 23, :private true, :arglists (quote ([f args] [f a0 args] [f a0 a1 args] [f a0 a1 a2 args] [f a0 a1 a2 a3 args])), :doc "Internal. DO NOT USE!\n  Assumes args was already called with seq beforehand!", :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([f args] [f a0 args] [f a0 a1 args] [f a0 a1 a2 args] [f a0 a1 a2 a3 args]), :arglists ([f args] [f a0 args] [f a0 a1 args] [f a0 a1 a2 args] [f a0 a1 a2 a3 args]), :arglists-meta (nil nil nil nil nil)}}, :private true, :name cljs.core/apply-to-simple, :variadic false, :file "cljs/core.cljs", :end-column 23, :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([f args] [f a0 args] [f a0 a1 args] [f a0 a1 a2 args] [f a0 a1 a2 a3 args]), :arglists ([f args] [f a0 args] [f a0 a1 args] [f a0 a1 a2 args] [f a0 a1 a2 a3 args]), :arglists-meta (nil nil nil nil nil)}, :method-params ([f args] [f a0 args] [f a0 a1 args] [f a0 a1 a2 args] [f a0 a1 a2 a3 args]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 3836, :end-line 3836, :max-fixed-arity 6, :fn-var true, :arglists ([f args] [f a0 args] [f a0 a1 args] [f a0 a1 a2 args] [f a0 a1 a2 a3 args]), :doc "Internal. DO NOT USE!\n  Assumes args was already called with seq beforehand!"}, methods {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10720, :column 7, :end-line 10720, :end-column 14, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns"}, :name cljs.core/methods, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10720, :end-line 10720, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns"}, odd? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4199, :column 16, :end-line 4199, :end-column 20, :tag boolean, :arglists (quote ([n])), :doc "Returns true if n is odd, throws an exception if n is not an integer"}, :name cljs.core/odd?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4199, :ret-tag boolean, :end-line 4199, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is odd, throws an exception if n is not an integer"}, ->ArrayChunk {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3468, :column 10, :end-line 3468, :end-column 20, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}, :factory :positional, :arglists (quote ([arr off end]))}, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :name cljs.core/->ArrayChunk, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([arr off end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3468, :end-line 3468, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr off end])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}}, ci-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1439, :column 8, :end-line 1439, :end-column 17, :private true, :arglists (quote ([cicoll f] [cicoll f val] [cicoll f val idx])), :doc "Accepts any collection which satisfies the ICount and IIndexed protocols and\nreduces them without incurring seq initialization", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([cicoll f] [cicoll f val] [cicoll f val idx]), :arglists ([cicoll f] [cicoll f val] [cicoll f val idx]), :arglists-meta (nil nil nil)}}, :private true, :name cljs.core/ci-reduce, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([cicoll f] [cicoll f val] [cicoll f val idx]), :arglists ([cicoll f] [cicoll f val] [cicoll f val idx]), :arglists-meta (nil nil nil)}, :method-params ([cicoll f] [cicoll f val] [cicoll f val idx]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1439, :end-line 1439, :max-fixed-arity 4, :fn-var true, :arglists ([cicoll f] [cicoll f val] [cicoll f val idx]), :doc "Accepts any collection which satisfies the ICount and IIndexed protocols and\nreduces them without incurring seq initialization"}, *3 {:name cljs.core/*3, :file "cljs/core.cljs", :line 195, :column 1, :end-line 197, :end-column 5, :doc "bound in a repl thread to the third most recent value printed", :meta {:file "cljs/core.cljs", :line 197, :column 3, :end-line 197, :end-column 5, :doc "bound in a repl thread to the third most recent value printed"}}, -get-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10510, :column 4, :end-line 10510, :end-column 15, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf dispatch-val]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-get-method, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([mf dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10505, :end-line 10510, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf dispatch-val])), :doc nil}, ->Var {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1098, :column 10, :end-line 1098, :end-column 13, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/IMeta cljs.core/Fn cljs.core/IDeref cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/IMeta cljs.core/IDeref cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([val sym _meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/IMeta cljs.core/Fn cljs.core/IDeref cljs.core/IWithMeta}, :name cljs.core/->Var, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([val sym _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1098, :end-line 1098, :max-fixed-arity 3, :fn-var true, :arglists (quote ([val sym _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/IMeta cljs.core/IDeref cljs.core/IWithMeta}}, frequencies {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9413, :column 7, :end-line 9413, :end-column 18, :arglists (quote ([coll])), :doc "Returns a map from distinct items in coll to the number of times\n  they appear."}, :name cljs.core/frequencies, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9413, :end-line 9413, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a map from distinct items in coll to the number of times\n  they appear."}, reduceable? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2115, :column 16, :end-line 2115, :end-column 27, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll satisfies IReduce"}, :name cljs.core/reduceable?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2115, :ret-tag boolean, :end-line 2115, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies IReduce"}, string-hash-cache {:name cljs.core/string-hash-cache, :file "cljs/core.cljs", :line 943, :column 1, :end-line 943, :end-column 23, :meta {:file "cljs/core.cljs", :line 943, :column 6, :end-line 943, :end-column 23}, :tag object}, rsubseq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9214, :column 7, :end-line 9214, :end-column 14, :arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :arglists ([sc test key] [sc start-test start-key end-test end-key]), :arglists-meta (nil nil)}}, :name cljs.core/rsubseq, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :arglists ([sc test key] [sc start-test start-key end-test end-key]), :arglists-meta (nil nil)}, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9214, :end-line 9214, :max-fixed-arity 5, :fn-var true, :arglists ([sc test key] [sc start-test start-key end-test end-key]), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true"}, inc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1399, :column 7, :end-line 1399, :end-column 10, :arglists (quote ([x])), :doc "Returns a number one greater than num."}, :name cljs.core/inc, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1399, :end-line 1399, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one greater than num."}, type->str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 308, :column 7, :end-line 308, :end-column 16, :arglists (quote ([ty]))}, :name cljs.core/type->str, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([ty]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 308, :end-line 308, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ty]))}, obj-clone {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6062, :column 8, :end-line 6062, :end-column 17, :private true, :arglists (quote ([obj ks]))}, :private true, :name cljs.core/obj-clone, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([obj ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6062, :end-line 6062, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj ks]))}, get-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10724, :column 7, :end-line 10724, :end-column 17, :arglists (quote ([multifn dispatch-val])), :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default"}, :name cljs.core/get-method, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([multifn dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10724, :end-line 10724, :max-fixed-arity 2, :fn-var true, :arglists (quote ([multifn dispatch-val])), :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default"}, uuid? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10787, :column 16, :end-line 10787, :end-column 21, :tag boolean, :arglists (quote ([x]))}, :name cljs.core/uuid?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10787, :ret-tag boolean, :end-line 10787, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x]))}, vector-index-out-of-bounds {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5086, :column 8, :end-line 5086, :end-column 34, :private true, :arglists (quote ([i cnt]))}, :private true, :name cljs.core/vector-index-out-of-bounds, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([i cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5086, :end-line 5086, :max-fixed-arity 2, :fn-var true, :arglists (quote ([i cnt]))}, es6-entries-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6211, :column 7, :end-line 6211, :end-column 27, :arglists (quote ([coll]))}, :name cljs.core/es6-entries-iterator, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6211, :end-line 6211, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, bit-clear {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2839, :column 7, :end-line 2839, :end-column 16, :arglists (quote ([x n])), :doc "Clear bit at index n"}, :name cljs.core/bit-clear, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2839, :end-line 2839, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Clear bit at index n"}, Range {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/Range, :file "cljs/core.cljs", :end-column 15, :type true, :column 10, :line 9240, :record false, :end-line 9240, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, filter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4844, :column 7, :end-line 4844, :end-column 13, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name cljs.core/filter, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4844, :end-line 4844, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."}, ->PersistentTreeMapSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7785, :column 10, :end-line 7785, :end-column 30, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta stack ascending? cnt __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->PersistentTreeMapSeq, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([meta stack ascending? cnt __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7785, :end-line 7785, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta stack ascending? cnt __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, create-array-node-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7472, :column 8, :end-line 7472, :end-column 29, :private true, :arglists (quote ([nodes] [meta nodes i s])), :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([nodes] [meta nodes i s]), :arglists ([nodes] [meta nodes i s]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/create-array-node-seq, :variadic false, :file "cljs/core.cljs", :end-column 29, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([nodes] [meta nodes i s]), :arglists ([nodes] [meta nodes i s]), :arglists-meta (nil nil)}, :method-params ([nodes] [meta nodes i s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7472, :end-line 7472, :max-fixed-arity 4, :fn-var true, :arglists ([nodes] [meta nodes i s])}, -assoc-n! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 794, :column 9, :end-line 794, :end-column 18, :tag clj, :protocol cljs.core/ITransientVector, :doc "Returns tcoll with value val added at position n.", :arglists (quote ([tcoll n val]))}, :protocol cljs.core/ITransientVector, :name cljs.core/-assoc-n!, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([tcoll n val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 792, :ret-tag clj, :end-line 794, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([tcoll n val])), :doc "Returns tcoll with value val added at position n."}, IWithMeta {:meta {:file "cljs/core.cljs", :line 672, :column 14, :end-line 672, :end-column 23, :doc "Protocol for adding metadata to an object.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-with-meta [[o meta]]}}}, :protocol-symbol true, :name cljs.core/IWithMeta, :file "cljs/core.cljs", :end-column 23, :column 1, :line 672, :protocol-info {:methods {-with-meta [[o meta]]}}, :info nil, :end-line 672, :tag any, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/t_cljs$core14407 cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/MetaFn cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding metadata to an object.", :jsdoc ("@interface")}, list {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3164, :column 7, :end-line 3164, :end-column 11, :arglists (quote ([& xs])), :doc "Creates a new list containing the items.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(xs)], :arglists ([& xs]), :arglists-meta (nil)}}, :name cljs.core/list, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(xs)], :arglists ([& xs]), :arglists-meta (nil)}, :method-params [(xs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 3164, :end-line 3164, :max-fixed-arity 0, :fn-var true, :arglists ([& xs]), :doc "Creates a new list containing the items."}, + {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2566, :column 15, :end-line 2566, :end-column 16, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/+, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 2566, :ret-tag number, :end-line 2566, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the sum of nums. (+) returns 0."}, IndexedSeqIterator {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/IndexedSeqIterator, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 1547, :record false, :end-line 1547, :skip-protocol-flag nil}, split-with {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9367, :column 7, :end-line 9367, :end-column 17, :arglists (quote ([pred coll])), :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"}, :name cljs.core/split-with, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9367, :end-line 9367, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"}, ->VectorNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5040, :column 10, :end-line 5040, :end-column 20, :protocols #{}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([edit arr]))}, :protocols #{}, :name cljs.core/->VectorNode, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([edit arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5040, :end-line 5040, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit arr])), :skip-protocol-flag nil}, aset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 491, :column 7, :end-line 491, :end-column 11, :arglists (quote ([array idx val] [array idx idx2 & idxv])), :doc "Sets the value at the index/indices. Works on JavaScript arrays.\n  Returns val.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([array idx val]), :arglists ([array idx val] [array idx idx2 & idxv]), :arglists-meta (nil nil)}}, :name cljs.core/aset, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([array idx val]), :arglists ([array idx val] [array idx idx2 & idxv]), :arglists-meta (nil nil)}, :method-params ([array idx val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 491, :end-line 491, :max-fixed-arity 3, :fn-var true, :arglists ([array idx val] [array idx idx2 & idxv]), :doc "Sets the value at the index/indices. Works on JavaScript arrays.\n  Returns val."}, int-rotate-left {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 878, :column 15, :end-line 878, :end-column 30, :tag number, :arglists (quote ([x n]))}, :name cljs.core/int-rotate-left, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 878, :ret-tag number, :end-line 878, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x n]))}, t_cljs$core10464 {:num-fields 1, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t_cljs$core10464, :file "cljs/core.cljs", :type true, :anonymous true, :column 3, :line 3948, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, keyword {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3347, :column 7, :end-line 3347, :end-column 14, :arglists (quote ([name] [ns name])), :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([name] [ns name]), :arglists ([name] [ns name]), :arglists-meta (nil nil)}}, :name cljs.core/keyword, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([name] [ns name]), :arglists ([name] [ns name]), :arglists-meta (nil nil)}, :method-params ([name] [ns name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3347, :end-line 3347, :max-fixed-arity 2, :fn-var true, :arglists ([name] [ns name]), :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically."}, ->Cons {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3181, :column 10, :end-line 3181, :end-column 14, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta first rest __hash]))}, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->Cons, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([meta first rest __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3181, :end-line 3181, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta first rest __hash])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, *ns* {:meta {:file "cljs/core.cljs", :line 53, :column 3, :end-line 53, :end-column 7, :dynamic true, :doc "Var bound to the current namespace. Only used for bootstrapping.", :jsdoc ["@type {*}"]}, :name cljs.core/*ns*, :file "cljs/core.cljs", :end-column 7, :column 1, :dynamic true, :line 49, :end-line 53, :tag clj-nil, :doc "Var bound to the current namespace. Only used for bootstrapping.", :jsdoc ["@type {*}"]}, *assert* {:name cljs.core/*assert*, :file "cljs/core.cljs", :line 60, :column 1, :end-line 62, :end-column 11, :dynamic true, :meta {:file "cljs/core.cljs", :line 62, :column 3, :end-line 62, :end-column 11, :dynamic true}, :tag boolean}, create-tree-map-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7854, :column 8, :end-line 7854, :end-column 27, :private true, :arglists (quote ([tree ascending? cnt]))}, :private true, :name cljs.core/create-tree-map-seq, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([tree ascending? cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7854, :end-line 7854, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tree ascending? cnt]))}, ICollection {:meta {:file "cljs/core.cljs", :line 569, :column 14, :end-line 569, :end-column 25, :doc "Protocol for adding to a collection.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-conj [[coll o]]}}}, :protocol-symbol true, :name cljs.core/ICollection, :file "cljs/core.cljs", :end-column 25, :column 1, :line 569, :protocol-info {:methods {-conj [[coll o]]}}, :info nil, :end-line 569, :tag any, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/MapEntry cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding to a collection.", :jsdoc ("@interface")}, chars {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2786, :column 7, :end-line 2786, :end-column 12, :arglists (quote ([x]))}, :name cljs.core/chars, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2786, :end-line 2786, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2924, :column 7, :end-line 2924, :end-column 10, :arglists (quote ([] [x] [x & ys])), :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([] [x]), :arglists ([] [x] [x & ys]), :arglists-meta (nil nil nil)}}, :name cljs.core/str, :variadic true, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([] [x]), :arglists ([] [x] [x & ys]), :arglists-meta (nil nil nil)}, :method-params ([] [x]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2924, :end-line 2924, :max-fixed-arity 1, :fn-var true, :arglists ([] [x] [x & ys]), :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args."}, next {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1237, :column 12, :end-line 1237, :end-column 16, :tag seq, :arglists (quote ([coll])), :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil"}, :name cljs.core/next, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1237, :ret-tag seq, :end-line 1237, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil"}, ASeq {:meta {:file "cljs/core.cljs", :line 586, :column 14, :end-line 586, :end-column 18, :doc "Marker protocol indicating an array sequence.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/ASeq, :file "cljs/core.cljs", :end-column 18, :column 1, :line 586, :protocol-info {:methods {}}, :info nil, :end-line 586, :tag any, :impls #{cljs.core/Cons cljs.core/IndexedSeq cljs.core/List cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :doc "Marker protocol indicating an array sequence.", :jsdoc ("@interface")}, pr-seq-writer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9705, :column 7, :end-line 9705, :end-column 20, :arglists (quote ([objs writer opts]))}, :name cljs.core/pr-seq-writer, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([objs writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9705, :end-line 9705, :max-fixed-arity 3, :fn-var true, :arglists (quote ([objs writer opts]))}, SeqIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/SeqIter, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 3981, :record false, :end-line 3981, :skip-protocol-flag nil}, IFn {:meta {:file "cljs/core.cljs", :line 525, :column 14, :end-line 525, :end-column 17, :doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-invoke [[this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]]}}}, :protocol-symbol true, :name cljs.core/IFn, :file "cljs/core.cljs", :end-column 17, :column 1, :line 525, :protocol-info {:methods {-invoke [[this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]]}}, :info nil, :end-line 525, :tag any, :impls #{cljs.core/PersistentHashMap cljs.core/MultiFn cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/Keyword cljs.core/BlackNode cljs.core/MapEntry cljs.core/Subvec cljs.core/Var cljs.core/PersistentVector cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/Symbol cljs.core/MetaFn cljs.core/RedNode}, :doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2", :jsdoc ("@interface")}, regexp? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9503, :column 16, :end-line 9503, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript RegExp instance."}, :name cljs.core/regexp?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9503, :ret-tag boolean, :end-line 9503, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript RegExp instance."}, hash-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8501, :column 7, :end-line 8501, :end-column 15, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new hash map with supplied mappings.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name cljs.core/hash-map, :variadic true, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8501, :end-line 8501, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new hash map with supplied mappings."}, underive {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10429, :column 7, :end-line 10429, :end-column 15, :arglists (quote ([tag parent] [h tag parent])), :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([tag parent] [h tag parent]), :arglists ([tag parent] [h tag parent]), :arglists-meta (nil nil)}}, :name cljs.core/underive, :variadic false, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([tag parent] [h tag parent]), :arglists ([tag parent] [h tag parent]), :arglists-meta (nil nil)}, :method-params ([tag parent] [h tag parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10429, :end-line 10429, :max-fixed-arity 3, :fn-var true, :arglists ([tag parent] [h tag parent]), :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy."}, array-copy {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2162, :column 8, :end-line 2162, :end-column 18, :private true, :arglists (quote ([from i to j len]))}, :private true, :name cljs.core/array-copy, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([from i to j len]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2162, :end-line 2162, :max-fixed-arity 5, :fn-var true, :arglists (quote ([from i to j len]))}, obj-map-compare-keys {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6040, :column 8, :end-line 6040, :end-column 28, :private true, :arglists (quote ([a b]))}, :private true, :name cljs.core/obj-map-compare-keys, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6040, :end-line 6040, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, -reset! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 839, :column 4, :end-line 839, :end-column 11, :protocol cljs.core/IReset, :doc "Sets the value of o to new-value.", :arglists (quote ([o new-value]))}, :protocol cljs.core/IReset, :name cljs.core/-reset!, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([o new-value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 837, :end-line 839, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o new-value])), :doc "Sets the value of o to new-value."}, -rest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 593, :column 9, :end-line 593, :end-column 14, :tag clj, :protocol cljs.core/ISeq, :doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()", :arglists (quote ([coll]))}, :protocol cljs.core/ISeq, :name cljs.core/-rest, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 589, :ret-tag clj, :end-line 593, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()"}, nil-iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3947, :column 7, :end-line 3947, :end-column 15, :arglists (quote ([]))}, :name cljs.core/nil-iter, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3947, :end-line 3947, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, pr-writer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9696, :column 8, :end-line 9696, :end-column 17, :private true, :arglists (quote ([obj writer opts])), :doc "Prefer this to pr-seq, because it makes the printing function\n   configurable, allowing efficient implementations such as appending\n   to a StringBuffer."}, :private true, :name cljs.core/pr-writer, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([obj writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9696, :end-line 9696, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts])), :doc "Prefer this to pr-seq, because it makes the printing function\n   configurable, allowing efficient implementations such as appending\n   to a StringBuffer."}, false? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2182, :column 16, :end-line 2182, :end-column 22, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is the value false, false otherwise."}, :name cljs.core/false?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2182, :ret-tag boolean, :end-line 2182, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is the value false, false otherwise."}, RangedIterator {:num-fields 6, :protocols #{cljs.core/Object}, :name cljs.core/RangedIterator, :file "cljs/core.cljs", :end-column 24, :type true, :column 10, :line 5137, :record false, :end-line 5137, :skip-protocol-flag nil}, *print-readably* {:meta {:file "cljs/core.cljs", :line 104, :column 3, :end-line 104, :end-column 19, :dynamic true, :doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true"}, :name cljs.core/*print-readably*, :file "cljs/core.cljs", :end-column 19, :column 1, :dynamic true, :line 98, :end-line 104, :tag boolean, :doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true"}, ints {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2788, :column 7, :end-line 2788, :end-column 11, :arglists (quote ([x]))}, :name cljs.core/ints, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2788, :end-line 2788, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, some-fn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4572, :column 7, :end-line 4572, :end-column 14, :arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([p] [p1 p2] [p1 p2 p3]), :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/some-fn, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([p] [p1 p2] [p1 p2 p3]), :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :arglists-meta (nil nil nil nil)}, :method-params ([p] [p1 p2] [p1 p2 p3]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 4572, :end-line 4572, :max-fixed-arity 3, :fn-var true, :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates."}, demunge-pattern {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10956, :column 8, :end-line 10956, :end-column 23, :private true, :arglists (quote ([]))}, :private true, :name cljs.core/demunge-pattern, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10956, :end-line 10956, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, *flush-on-newline* {:meta {:file "cljs/core.cljs", :line 89, :column 3, :end-line 89, :end-column 21, :dynamic true, :doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true."}, :name cljs.core/*flush-on-newline*, :file "cljs/core.cljs", :end-column 21, :column 1, :dynamic true, :line 84, :end-line 89, :tag boolean, :doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true."}, to-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3596, :column 7, :end-line 3596, :end-column 15, :arglists (quote ([s])), :doc "Naive impl of to-array as a start."}, :name cljs.core/to-array, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3596, :end-line 3596, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Naive impl of to-array as a start."}, build-subvec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5643, :column 8, :end-line 5643, :end-column 20, :private true, :arglists (quote ([meta v start end __hash]))}, :private true, :name cljs.core/build-subvec, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([meta v start end __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5643, :end-line 5643, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta v start end __hash]))}, maybe-warn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 435, :column 8, :end-line 435, :end-column 18, :private true, :arglists (quote ([e]))}, :private true, :name cljs.core/maybe-warn, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([e]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 435, :end-line 435, :max-fixed-arity 1, :fn-var true, :arglists (quote ([e]))}, Namespace {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object}, :name cljs.core/Namespace, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 11027, :record false, :end-line 11027, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash}}, list? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3071, :column 16, :end-line 3071, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x implements IList"}, :name cljs.core/list?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3071, :ret-tag boolean, :end-line 3071, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x implements IList"}, tree-map-remove {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8316, :column 8, :end-line 8316, :end-column 23, :private true, :arglists (quote ([comp tree k found]))}, :private true, :name cljs.core/tree-map-remove, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([comp tree k found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8316, :end-line 8316, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp tree k found]))}, PersistentQueueIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/PersistentQueueIter, :file "cljs/core.cljs", :end-column 29, :type true, :column 10, :line 5857, :record false, :end-line 5857, :skip-protocol-flag nil}, HashCollisionNode {:num-fields 4, :protocols #{cljs.core/Object cljs.core/IIterable}, :name cljs.core/HashCollisionNode, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7221, :record false, :end-line 7221, :skip-protocol-flag #{cljs.core/IIterable}}, array? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 222, :column 16, :end-line 222, :end-column 22, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript array."}, :name cljs.core/array?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 222, :ret-tag boolean, :end-line 222, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript array."}, prefers* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10455, :column 8, :end-line 10455, :end-column 16, :private true, :arglists (quote ([x y prefer-table]))}, :private true, :name cljs.core/prefers*, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x y prefer-table]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10455, :end-line 10455, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x y prefer-table]))}, simple-ident? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3323, :column 16, :end-line 3323, :end-column 29, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a symbol or keyword without a namespace"}, :name cljs.core/simple-ident?, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3323, :ret-tag boolean, :end-line 3323, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a symbol or keyword without a namespace"}, clone {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1180, :column 7, :end-line 1180, :end-column 12, :arglists (quote ([value])), :doc "Clone the supplied value which must implement ICloneable."}, :name cljs.core/clone, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1180, :end-line 1180, :max-fixed-arity 1, :fn-var true, :arglists (quote ([value])), :doc "Clone the supplied value which must implement ICloneable."}, scan-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6026, :column 8, :end-line 6026, :end-column 18, :private true, :arglists (quote ([incr k array]))}, :private true, :name cljs.core/scan-array, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([incr k array]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6026, :end-line 6026, :max-fixed-arity 3, :fn-var true, :arglists (quote ([incr k array]))}, demunge {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 11011, :column 7, :end-line 11011, :end-column 14, :arglists (quote ([name]))}, :name cljs.core/demunge, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 11011, :end-line 11011, :max-fixed-arity 1, :fn-var true, :arglists (quote ([name]))}, bit-not {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2849, :column 7, :end-line 2849, :end-column 14, :arglists (quote ([x])), :doc "Bitwise complement"}, :name cljs.core/bit-not, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2849, :end-line 2849, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Bitwise complement"}, quote-string {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9600, :column 17, :end-line 9600, :end-column 29, :private true, :arglists (quote ([s]))}, :private true, :name cljs.core/quote-string, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9600, :end-line 9600, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, byte {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2663, :column 15, :end-line 2663, :end-column 19, :tag number, :arglists (quote ([x]))}, :name cljs.core/byte, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2663, :ret-tag number, :end-line 2663, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, max {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2649, :column 15, :end-line 2649, :end-column 18, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns the greatest of the nums.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/max, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2649, :ret-tag number, :end-line 2649, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns the greatest of the nums."}, IComparable {:meta {:file "cljs/core.cljs", :line 804, :column 14, :end-line 804, :end-column 25, :doc "Protocol for values that can be compared.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-compare [[x y]]}}}, :protocol-symbol true, :name cljs.core/IComparable, :file "cljs/core.cljs", :end-column 25, :column 1, :line 804, :protocol-info {:methods {-compare [[x y]]}}, :info nil, :end-line 804, :tag any, :impls #{js/Date cljs.core/Keyword cljs.core/BlackNode cljs.core/MapEntry cljs.core/Subvec cljs.core/PersistentVector cljs.core/Symbol cljs.core/UUID cljs.core/RedNode}, :doc "Protocol for values that can be compared.", :jsdoc ("@interface")}, == {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2886, :column 16, :end-line 2886, :end-column 18, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/==, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2886, :ret-tag boolean, :end-line 2886, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined."}, parents {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10370, :column 7, :end-line 10370, :end-column 14, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}}, :name cljs.core/parents, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}, :method-params ([tag] [h tag]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10370, :end-line 10370, :max-fixed-arity 2, :fn-var true, :arglists ([tag] [h tag]), :doc "Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy"}, count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1788, :column 7, :end-line 1788, :end-column 12, :arglists (quote ([coll])), :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps"}, :name cljs.core/count, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1788, :end-line 1788, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps"}, -disjoin! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 801, :column 9, :end-line 801, :end-column 18, :tag clj, :protocol cljs.core/ITransientSet, :doc "Returns tcoll without v.", :arglists (quote ([tcoll v]))}, :protocol cljs.core/ITransientSet, :name cljs.core/-disjoin!, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([tcoll v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 799, :ret-tag clj, :end-line 801, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll v])), :doc "Returns tcoll without v."}, *loaded-libs* {:meta {:file "cljs/core.cljs", :line 164, :column 3, :end-line 164, :end-column 16, :dynamic true, :jsdoc ["@type {*}"]}, :name cljs.core/*loaded-libs*, :file "cljs/core.cljs", :end-column 16, :column 1, :dynamic true, :line 161, :end-line 164, :tag clj-nil, :jsdoc ["@type {*}"]}, t_cljs$core8963 {:num-fields 1, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t_cljs$core8963, :file "cljs/core.cljs", :type true, :anonymous true, :column 3, :line 3948, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, EMPTY {:name cljs.core/EMPTY, :file "cljs/core.cljs", :line 4055, :column 1, :end-line 4055, :end-column 21, :private true, :meta {:file "cljs/core.cljs", :line 4055, :column 16, :end-line 4055, :end-column 21, :private true}, :tag cljs.core/Empty}, ->TransientHashMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7673, :column 10, :end-line 7673, :end-column 26, :protocols #{cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :factory :positional, :arglists (quote ([edit root count has-nil? nil-val]))}, :protocols #{cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientHashMap, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([edit root count has-nil? nil-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7673, :end-line 7673, :max-fixed-arity 5, :fn-var true, :arglists (quote ([edit root count has-nil? nil-val])), :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, array-index-of-symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6247, :column 8, :end-line 6247, :end-column 30, :private true, :arglists (quote ([arr k]))}, :private true, :name cljs.core/array-index-of-symbol?, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6247, :end-line 6247, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, ArrayChunk {:meta {:file "cljs/core.cljs", :line 3449, :column 10, :end-line 3449, :end-column 20, :declared true}, :num-fields 3, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :name cljs.core/ArrayChunk, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 3468, :record false, :declared true, :end-line 3468, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}}, sorted-map-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8541, :column 7, :end-line 8541, :end-column 20, :arglists (quote ([comparator & keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keyvals)], :arglists ([comparator & keyvals]), :arglists-meta (nil)}}, :name cljs.core/sorted-map-by, :variadic true, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keyvals)], :arglists ([comparator & keyvals]), :arglists-meta (nil)}, :method-params [(comparator keyvals)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8541, :end-line 8541, :max-fixed-arity 1, :fn-var true, :arglists ([comparator & keyvals]), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator."}, apply {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3870, :column 7, :end-line 3870, :end-column 12, :arglists (quote ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args])), :doc "Applies fn f to the argument list formed by prepending intervening arguments to args.", :top-fn {:variadic true, :max-fixed-arity 5, :method-params ([f args] [f x args] [f x y args] [f x y z args]), :arglists ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/apply, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 5, :method-params ([f args] [f x args] [f x y args] [f x y z args]), :arglists ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]), :arglists-meta (nil nil nil nil nil)}, :method-params ([f args] [f x args] [f x y args] [f x y z args]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 3870, :end-line 3870, :max-fixed-arity 5, :fn-var true, :arglists ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]), :doc "Applies fn f to the argument list formed by prepending intervening arguments to args."}, get-global-hierarchy {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10342, :column 8, :end-line 10342, :end-column 28, :private true, :arglists (quote ([]))}, :private true, :name cljs.core/get-global-hierarchy, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10342, :end-line 10342, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, add-to-string-hash-cache {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 958, :column 7, :end-line 958, :end-column 31, :arglists (quote ([k]))}, :name cljs.core/add-to-string-hash-cache, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 958, :end-line 958, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, clj->js {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10219, :column 7, :end-line 10219, :end-column 14, :arglists (quote ([x])), :doc "Recursively transforms ClojureScript values to JavaScript.\n  sets/vectors/lists become Arrays, Keywords and Symbol become Strings,\n  Maps become Objects. Arbitrary keys are encoded to by key->js."}, :name cljs.core/clj->js, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10219, :end-line 10219, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Recursively transforms ClojureScript values to JavaScript.\n  sets/vectors/lists become Arrays, Keywords and Symbol become Strings,\n  Maps become Objects. Arbitrary keys are encoded to by key->js."}, TransientArrayMap {:meta {:file "cljs/core.cljs", :line 6304, :column 10, :end-line 6304, :end-column 27, :declared true}, :num-fields 3, :protocols #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientArrayMap, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 6696, :record false, :declared true, :end-line 6696, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, ->TransientVector {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5724, :column 10, :end-line 5724, :end-column 25, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :factory :positional, :arglists (quote ([cnt shift root tail]))}, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientVector, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([cnt shift root tail]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5724, :end-line 5724, :max-fixed-arity 4, :fn-var true, :arglists (quote ([cnt shift root tail])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}}, IChunkedNext {:meta {:file "cljs/core.cljs", :line 822, :column 14, :end-line 822, :end-column 26, :doc "Protocol for accessing the chunks of a collection.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-chunked-next [[coll]]}}}, :protocol-symbol true, :name cljs.core/IChunkedNext, :file "cljs/core.cljs", :end-column 26, :column 1, :line 822, :protocol-info {:methods {-chunked-next [[coll]]}}, :info nil, :end-line 822, :tag any, :impls #{cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :doc "Protocol for accessing the chunks of a collection.", :jsdoc ("@interface")}, interpose {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4798, :column 7, :end-line 4798, :end-column 16, :arglists (quote ([sep] [sep coll])), :doc "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([sep] [sep coll]), :arglists ([sep] [sep coll]), :arglists-meta (nil nil)}}, :name cljs.core/interpose, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([sep] [sep coll]), :arglists ([sep] [sep coll]), :arglists-meta (nil nil)}, :method-params ([sep] [sep coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4798, :end-line 4798, :max-fixed-arity 2, :fn-var true, :arglists ([sep] [sep coll]), :doc "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided."}, TransformerIterator {:num-fields 6, :protocols #{cljs.core/Object}, :name cljs.core/TransformerIterator, :file "cljs/core.cljs", :end-column 29, :type true, :column 10, :line 4084, :record false, :end-line 4084, :skip-protocol-flag nil}, ->BlackNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7957, :column 10, :end-line 7957, :end-column 19, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :factory :positional, :arglists (quote ([key val left right __hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->BlackNode, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([key val left right __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7957, :end-line 7957, :max-fixed-arity 5, :fn-var true, :arglists (quote ([key val left right __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, deref {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1431, :column 7, :end-line 1431, :end-column 12, :arglists (quote ([o])), :doc "Also reader macro: @var/@atom/@delay. Returns the\n   most-recently-committed value of ref. When applied to a var\n   or atom, returns its current state. When applied to a delay, forces\n   it if not already forced. See also - realized?."}, :name cljs.core/deref, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1431, :end-line 1431, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Also reader macro: @var/@atom/@delay. Returns the\n   most-recently-committed value of ref. When applied to a var\n   or atom, returns its current state. When applied to a delay, forces\n   it if not already forced. See also - realized?."}, pv-aget {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5045, :column 8, :end-line 5045, :end-column 15, :private true, :arglists (quote ([node idx]))}, :private true, :name cljs.core/pv-aget, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([node idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5045, :end-line 5045, :max-fixed-arity 2, :fn-var true, :arglists (quote ([node idx]))}, assoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1947, :column 7, :end-line 1947, :end-column 12, :arglists (quote ([coll k v] [coll k v & kvs])), :doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([coll k v]), :arglists ([coll k v] [coll k v & kvs]), :arglists-meta (nil nil)}}, :name cljs.core/assoc, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([coll k v]), :arglists ([coll k v] [coll k v & kvs]), :arglists-meta (nil nil)}, :method-params ([coll k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1947, :end-line 1947, :max-fixed-arity 3, :fn-var true, :arglists ([coll k v] [coll k v & kvs]), :doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index."}, transient {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3764, :column 7, :end-line 3764, :end-column 16, :arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time."}, :name cljs.core/transient, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3764, :end-line 3764, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time."}, -disjoin {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 641, :column 9, :end-line 641, :end-column 17, :tag clj, :protocol cljs.core/ISet, :doc "Returns a new collection of coll that does not contain v.", :arglists (quote ([coll v]))}, :protocol cljs.core/ISet, :name cljs.core/-disjoin, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 639, :ret-tag clj, :end-line 641, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll v])), :doc "Returns a new collection of coll that does not contain v."}, chunk-cons {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3572, :column 7, :end-line 3572, :end-column 17, :arglists (quote ([chunk rest]))}, :name cljs.core/chunk-cons, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([chunk rest]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3572, :end-line 3572, :max-fixed-arity 2, :fn-var true, :arglists (quote ([chunk rest]))}, ArrayIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/ArrayIter, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 3966, :record false, :end-line 3966, :skip-protocol-flag nil}, comparator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10861, :column 7, :end-line 10861, :end-column 17, :arglists (quote ([pred])), :doc "Returns an JavaScript compatible comparator based upon pred."}, :name cljs.core/comparator, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pred]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10861, :end-line 10861, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pred])), :doc "Returns an JavaScript compatible comparator based upon pred."}, print-prefix-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9820, :column 7, :end-line 9820, :end-column 23, :arglists (quote ([prefix m print-one writer opts]))}, :name cljs.core/print-prefix-map, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([prefix m print-one writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9820, :end-line 9820, :max-fixed-arity 5, :fn-var true, :arglists (quote ([prefix m print-one writer opts]))}, sorted-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8532, :column 7, :end-line 8532, :end-column 17, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name cljs.core/sorted-map, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8532, :end-line 8532, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings."}, drop-while {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4724, :column 7, :end-line 4724, :end-column 17, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name cljs.core/drop-while, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4724, :end-line 4724, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided."}, IWriter {:meta {:file "cljs/core.cljs", :line 738, :column 14, :end-line 738, :end-column 21, :doc "Protocol for writing. Currently only implemented by StringBufferWriter.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-write [[writer s]], -flush [[writer]]}}}, :protocol-symbol true, :name cljs.core/IWriter, :file "cljs/core.cljs", :end-column 21, :column 1, :line 738, :protocol-info {:methods {-write [[writer s]], -flush [[writer]]}}, :info nil, :end-line 738, :tag any, :impls #{cljs.core/StringBufferWriter}, :doc "Protocol for writing. Currently only implemented by StringBufferWriter.", :jsdoc ("@interface")}, t_cljs$core14407 {:num-fields 1, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t_cljs$core14407, :file "cljs/core.cljs", :type true, :anonymous true, :column 3, :line 3948, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, KeySeq {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/KeySeq, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 8551, :record false, :end-line 8551, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, realized? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10081, :column 16, :end-line 10081, :end-column 25, :tag boolean, :arglists (quote ([x])), :doc "Returns true if a value has been produced for a delay or lazy sequence."}, :name cljs.core/realized?, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10081, :ret-tag boolean, :end-line 10081, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if a value has been produced for a delay or lazy sequence."}, *print-fn* {:meta {:file "cljs/core.cljs", :line 68, :column 3, :end-line 68, :end-column 13, :doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.", :dynamic true}, :name cljs.core/*print-fn*, :file "cljs/core.cljs", :end-column 13, :column 1, :dynamic true, :line 64, :end-line 68, :tag clj-nil, :doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed."}, compare {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2343, :column 15, :end-line 2343, :end-column 22, :tag number, :arglists (quote ([x y])), :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object."}, :name cljs.core/compare, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2343, :ret-tag number, :end-line 2343, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x y])), :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object."}, complement {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4203, :column 16, :end-line 4203, :end-column 26, :tag boolean, :arglists (quote ([f])), :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value."}, :name cljs.core/complement, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4203, :ret-tag boolean, :end-line 4203, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value."}, lookup-sentinel {:name cljs.core/lookup-sentinel, :file "cljs/core.cljs", :line 2180, :column 1, :end-line 2180, :end-column 31, :private true, :meta {:file "cljs/core.cljs", :line 2180, :column 16, :end-line 2180, :end-column 31, :private true}, :tag object}, -assoc! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 783, :column 9, :end-line 783, :end-column 16, :tag clj, :protocol cljs.core/ITransientAssociative, :doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it.", :arglists (quote ([tcoll key val]))}, :protocol cljs.core/ITransientAssociative, :name cljs.core/-assoc!, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([tcoll key val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 781, :ret-tag clj, :end-line 783, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([tcoll key val])), :doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it."}, *print-dup* {:meta {:file "cljs/core.cljs", :line 120, :column 3, :end-line 120, :end-column 14, :dynamic true, :doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false."}, :name cljs.core/*print-dup*, :file "cljs/core.cljs", :end-column 14, :column 1, :dynamic true, :line 114, :end-line 120, :tag boolean, :doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false."}, string-iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3963, :column 7, :end-line 3963, :end-column 18, :arglists (quote ([x]))}, :name cljs.core/string-iter, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3963, :end-line 3963, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, -key->js {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10204, :column 4, :end-line 10204, :end-column 12, :protocol cljs.core/IEncodeJS, :doc "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)", :arglists (quote ([x]))}, :protocol cljs.core/IEncodeJS, :name cljs.core/-key->js, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10202, :end-line 10204, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)"}, IDeref {:meta {:file "cljs/core.cljs", :line 659, :column 14, :end-line 659, :end-column 20, :doc "Protocol for adding dereference functionality to a reference.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-deref [[o]]}}}, :protocol-symbol true, :name cljs.core/IDeref, :file "cljs/core.cljs", :end-column 20, :column 1, :line 659, :protocol-info {:methods {-deref [[o]]}}, :info nil, :end-line 659, :tag any, :impls #{cljs.core/Reduced cljs.core/Volatile cljs.core/Delay cljs.core/Var cljs.core/Atom}, :doc "Protocol for adding dereference functionality to a reference.", :jsdoc ("@interface")}, sequence {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4143, :column 7, :end-line 4143, :end-column 15, :arglists (quote ([coll] [xform coll] [xform coll & colls])), :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [xform coll]), :arglists ([coll] [xform coll] [xform coll & colls]), :arglists-meta (nil nil nil)}}, :name cljs.core/sequence, :variadic true, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [xform coll]), :arglists ([coll] [xform coll] [xform coll & colls]), :arglists-meta (nil nil nil)}, :method-params ([coll] [xform coll]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 4143, :end-line 4143, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [xform coll] [xform coll & colls]), :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments"}, constantly {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4213, :column 7, :end-line 4213, :end-column 17, :arglists (quote ([x])), :doc "Returns a function that takes any number of arguments and returns x."}, :name cljs.core/constantly, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4213, :end-line 4213, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a function that takes any number of arguments and returns x."}, ->RangedIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5137, :column 10, :end-line 5137, :end-column 24, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([i base arr v start end]))}, :protocols #{cljs.core/Object}, :name cljs.core/->RangedIterator, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([i base arr v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5137, :end-line 5137, :max-fixed-arity 6, :fn-var true, :arglists (quote ([i base arr v start end])), :skip-protocol-flag nil}, chunked-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5502, :column 7, :end-line 5502, :end-column 18, :arglists (quote ([vec i off] [vec node i off] [vec node i off meta])), :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([vec i off] [vec node i off] [vec node i off meta]), :arglists ([vec i off] [vec node i off] [vec node i off meta]), :arglists-meta (nil nil nil)}}, :name cljs.core/chunked-seq, :variadic false, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([vec i off] [vec node i off] [vec node i off meta]), :arglists ([vec i off] [vec node i off] [vec node i off meta]), :arglists-meta (nil nil nil)}, :method-params ([vec i off] [vec node i off] [vec node i off meta]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 5502, :end-line 5502, :max-fixed-arity 5, :fn-var true, :arglists ([vec i off] [vec node i off] [vec node i off meta])}, ISorted {:meta {:file "cljs/core.cljs", :line 721, :column 14, :end-line 721, :end-column 21, :doc "Protocol for a collection which can represent their items\n  in a sorted manner. ", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-sorted-seq [[coll ascending?]], -sorted-seq-from [[coll k ascending?]], -entry-key [[coll entry]], -comparator [[coll]]}}}, :protocol-symbol true, :name cljs.core/ISorted, :file "cljs/core.cljs", :end-column 21, :column 1, :line 721, :protocol-info {:methods {-sorted-seq [[coll ascending?]], -sorted-seq-from [[coll k ascending?]], -entry-key [[coll entry]], -comparator [[coll]]}}, :info nil, :end-line 721, :tag any, :impls #{cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet}, :doc "Protocol for a collection which can represent their items\n  in a sorted manner. ", :jsdoc ("@interface")}, make-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 398, :column 14, :end-line 398, :end-column 24, :tag array, :arglists (quote ([size] [type size] [type size & more-sizes])), :doc "Construct a JavaScript array of the specified dimensions. Accepts ignored\n  type argument for compatibility with Clojure. Note that there is no efficient\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\n  will run in polynomial time when called with 3 or more arguments.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([size] [type size]), :arglists ([size] [type size] [type size & more-sizes]), :arglists-meta (nil nil nil)}}, :name cljs.core/make-array, :variadic true, :file "cljs/core.cljs", :end-column 24, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([size] [type size]), :arglists ([size] [type size] [type size & more-sizes]), :arglists-meta (nil nil nil)}, :method-params ([size] [type size]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 398, :ret-tag array, :end-line 398, :max-fixed-arity 2, :tag array, :fn-var true, :arglists ([size] [type size] [type size & more-sizes]), :doc "Construct a JavaScript array of the specified dimensions. Accepts ignored\n  type argument for compatibility with Clojure. Note that there is no efficient\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\n  will run in polynomial time when called with 3 or more arguments."}, checked-aget {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 440, :column 8, :end-line 440, :end-column 20, :private true, :arglists (quote ([array idx] [array idx & idxs])), :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([array idx]), :arglists ([array idx] [array idx & idxs]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/checked-aget, :variadic true, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([array idx]), :arglists ([array idx] [array idx & idxs]), :arglists-meta (nil nil)}, :method-params ([array idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 440, :end-line 440, :max-fixed-arity 2, :fn-var true, :arglists ([array idx] [array idx & idxs])}, shorts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2787, :column 7, :end-line 2787, :end-column 13, :arglists (quote ([x]))}, :name cljs.core/shorts, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2787, :end-line 2787, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, *unchecked-if* {:name cljs.core/*unchecked-if*, :file "cljs/core.cljs", :line 25, :column 1, :end-line 25, :end-column 20, :meta {:file "cljs/core.cljs", :line 25, :column 6, :end-line 25, :end-column 20}, :tag boolean}, ->RSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1661, :column 10, :end-line 1661, :end-column 14, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([ci i meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->RSeq, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([ci i meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1661, :end-line 1661, :max-fixed-arity 3, :fn-var true, :arglists (quote ([ci i meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, enable-console-print! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 175, :column 7, :end-line 175, :end-column 28, :arglists (quote ([])), :doc "Set *print-fn* to console.log"}, :name cljs.core/enable-console-print!, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 175, :end-line 175, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Set *print-fn* to console.log"}, -flush {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 742, :column 4, :end-line 742, :end-column 10, :protocol cljs.core/IWriter, :doc "Flush writer.", :arglists (quote ([writer]))}, :protocol cljs.core/IWriter, :name cljs.core/-flush, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([writer]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 738, :end-line 742, :max-fixed-arity 1, :fn-var true, :arglists (quote ([writer])), :doc "Flush writer."}, -lastIndexOf {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1530, :column 8, :end-line 1530, :end-column 20, :private true, :arglists (quote ([coll x] [coll x start])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll x] [coll x start]), :arglists ([coll x] [coll x start]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/-lastIndexOf, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll x] [coll x start]), :arglists ([coll x] [coll x start]), :arglists-meta (nil nil)}, :method-params ([coll x] [coll x start]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1530, :end-line 1530, :max-fixed-arity 3, :fn-var true, :arglists ([coll x] [coll x start])}, completing {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2537, :column 7, :end-line 2537, :end-column 17, :arglists (quote ([f] [f cf])), :doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f cf]), :arglists ([f] [f cf]), :arglists-meta (nil nil)}}, :name cljs.core/completing, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f cf]), :arglists ([f] [f cf]), :arglists-meta (nil nil)}, :method-params ([f] [f cf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2537, :end-line 2537, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f cf]), :doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument."}, unchecked-negate-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2737, :column 7, :end-line 2737, :end-column 27, :arglists (quote ([x]))}, :name cljs.core/unchecked-negate-int, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2737, :end-line 2737, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, ->PersistentVector {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5178, :column 10, :end-line 5178, :end-column 26, :protocols #{cljs.core/APersistentVector cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta cnt shift root tail __hash]))}, :protocols #{cljs.core/APersistentVector cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->PersistentVector, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([meta cnt shift root tail __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5178, :end-line 5178, :max-fixed-arity 6, :fn-var true, :arglists (quote ([meta cnt shift root tail __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, equiv-sequential {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2946, :column 8, :end-line 2946, :end-column 24, :private true, :arglists (quote ([x y])), :doc "Assumes x is sequential. Returns true if x equals y, otherwise\n  returns false."}, :private true, :name cljs.core/equiv-sequential, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2946, :end-line 2946, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Assumes x is sequential. Returns true if x equals y, otherwise\n  returns false."}, hash-unordered-coll {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1327, :column 15, :end-line 1327, :end-column 34, :tag number, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms."}, :name cljs.core/hash-unordered-coll, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1327, :ret-tag number, :end-line 1327, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms."}, repeat {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4760, :column 7, :end-line 4760, :end-column 13, :arglists (quote ([x] [n x])), :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([x] [n x]), :arglists ([x] [n x]), :arglists-meta (nil nil)}}, :name cljs.core/repeat, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([x] [n x]), :arglists ([x] [n x]), :arglists-meta (nil nil)}, :method-params ([x] [n x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4760, :end-line 4760, :max-fixed-arity 2, :fn-var true, :arglists ([x] [n x]), :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs."}, unchecked-inc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2714, :column 7, :end-line 2714, :end-column 20, :arglists (quote ([x]))}, :name cljs.core/unchecked-inc, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2714, :end-line 2714, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, nthnext {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2914, :column 7, :end-line 2914, :end-column 14, :arglists (quote ([coll n])), :doc "Returns the nth next of coll, (seq coll) when n is 0."}, :name cljs.core/nthnext, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2914, :end-line 2914, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll n])), :doc "Returns the nth next of coll, (seq coll) when n is 0."}, preserving-reduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10086, :column 8, :end-line 10086, :end-column 26, :private true, :arglists (quote ([rf]))}, :private true, :name cljs.core/preserving-reduced, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([rf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10086, :end-line 10086, :max-fixed-arity 1, :fn-var true, :arglists (quote ([rf]))}, get-validator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4470, :column 7, :end-line 4470, :end-column 20, :arglists (quote ([iref])), :doc "Gets the validator-fn for a var/ref/agent/atom."}, :name cljs.core/get-validator, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([iref]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4470, :end-line 4470, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iref])), :doc "Gets the validator-fn for a var/ref/agent/atom."}, StringIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/StringIter, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 3954, :record false, :end-line 3954, :skip-protocol-flag nil}, number? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 229, :column 16, :end-line 229, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript number."}, :name cljs.core/number?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 229, :ret-tag boolean, :end-line 229, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript number."}, -conj! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 776, :column 9, :end-line 776, :end-column 15, :tag clj, :protocol cljs.core/ITransientCollection, :doc "Adds value val to tcoll and returns tcoll.", :arglists (quote ([tcoll val]))}, :protocol cljs.core/ITransientCollection, :name cljs.core/-conj!, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([tcoll val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 774, :ret-tag clj, :end-line 776, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll val])), :doc "Adds value val to tcoll and returns tcoll."}, ->PersistentArrayMapSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6398, :column 10, :end-line 6398, :end-column 31, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([arr i _meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->PersistentArrayMapSeq, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([arr i _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6398, :end-line 6398, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, chunk-next {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3589, :column 7, :end-line 3589, :end-column 17, :arglists (quote ([s]))}, :name cljs.core/chunk-next, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3589, :end-line 3589, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, ArrayList {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ArrayList, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 9132, :record false, :end-line 9132, :skip-protocol-flag nil}, print-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9774, :column 7, :end-line 9774, :end-column 16, :arglists (quote ([& objs])), :doc "print to a string, returning it", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/print-str, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9774, :end-line 9774, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "print to a string, returning it"}, not-any? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4188, :column 16, :end-line 4188, :end-column 24, :tag boolean, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for any x in coll,\n  else true."}, :name cljs.core/not-any?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4188, :ret-tag boolean, :end-line 4188, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for any x in coll,\n  else true."}, into-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 506, :column 14, :end-line 506, :end-column 24, :tag array, :arglists (quote ([aseq] [type aseq])), :doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([aseq] [type aseq]), :arglists ([aseq] [type aseq]), :arglists-meta (nil nil)}}, :name cljs.core/into-array, :variadic false, :file "cljs/core.cljs", :end-column 24, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([aseq] [type aseq]), :arglists ([aseq] [type aseq]), :arglists-meta (nil nil)}, :method-params ([aseq] [type aseq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 506, :ret-tag array, :end-line 506, :max-fixed-arity 2, :tag array, :fn-var true, :arglists ([aseq] [type aseq]), :doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure."}, -hash {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 699, :column 4, :end-line 699, :end-column 9, :protocol cljs.core/IHash, :doc "Returns the hash code of o.", :arglists (quote ([o]))}, :protocol cljs.core/IHash, :name cljs.core/-hash, :variadic false, :file "cljs/core.cljs", :end-column 9, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 697, :end-line 699, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the hash code of o."}, qualified-symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3335, :column 16, :end-line 3335, :end-column 33, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a symbol with a namespace"}, :name cljs.core/qualified-symbol?, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3335, :ret-tag boolean, :end-line 3335, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a symbol with a namespace"}, -dissoc! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 789, :column 9, :end-line 789, :end-column 17, :tag clj, :protocol cljs.core/ITransientMap, :doc "Returns a new transient collection of tcoll without the mapping for key.", :arglists (quote ([tcoll key]))}, :protocol cljs.core/ITransientMap, :name cljs.core/-dissoc!, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([tcoll key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 787, :ret-tag clj, :end-line 789, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll key])), :doc "Returns a new transient collection of tcoll without the mapping for key."}, ->Reduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1405, :column 10, :end-line 1405, :end-column 17, :protocols #{cljs.core/IDeref}, :skip-protocol-flag #{cljs.core/IDeref}, :factory :positional, :arglists (quote ([val]))}, :protocols #{cljs.core/IDeref}, :name cljs.core/->Reduced, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1405, :end-line 1405, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :skip-protocol-flag #{cljs.core/IDeref}}, chunk-buffer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3465, :column 7, :end-line 3465, :end-column 19, :arglists (quote ([capacity]))}, :name cljs.core/chunk-buffer, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([capacity]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3465, :end-line 3465, :max-fixed-arity 1, :fn-var true, :arglists (quote ([capacity]))}, seqable? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2206, :column 16, :end-line 2206, :end-column 24, :tag boolean, :arglists (quote ([s])), :doc "Return true if the seq function is supported for s"}, :name cljs.core/seqable?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2206, :ret-tag boolean, :end-line 2206, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([s])), :doc "Return true if the seq function is supported for s"}, symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1024, :column 16, :end-line 1024, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a Symbol"}, :name cljs.core/symbol?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1024, :ret-tag boolean, :end-line 1024, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a Symbol"}, m3-hash-unencoded-chars {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 924, :column 15, :end-line 924, :end-column 38, :tag number, :arglists (quote ([in]))}, :name cljs.core/m3-hash-unencoded-chars, :variadic false, :file "cljs/core.cljs", :end-column 38, :method-params ([in]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 924, :ret-tag number, :end-line 924, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([in]))}, unchecked-char {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2678, :column 15, :end-line 2678, :end-column 29, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-char, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2678, :ret-tag number, :end-line 2678, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, system-time {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 379, :column 7, :end-line 379, :end-column 18, :arglists (quote ([])), :doc "Returns highest resolution time offered by host in milliseconds."}, :name cljs.core/system-time, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 379, :end-line 379, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Returns highest resolution time offered by host in milliseconds."}, NeverEquiv {:num-fields 0, :protocols #{cljs.core/IEquiv cljs.core/Object}, :name cljs.core/NeverEquiv, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 5997, :record false, :end-line 5997, :skip-protocol-flag #{cljs.core/IEquiv}}, chunkIteratorSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4073, :column 8, :end-line 4073, :end-column 24, :private true, :arglists (quote ([iter]))}, :private true, :name cljs.core/chunkIteratorSeq, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4073, :end-line 4073, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iter]))}, -invoke {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 529, :column 4, :end-line 529, :end-column 11, :protocol cljs.core/IFn, :doc nil, :arglists (quote ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest])), :top-fn {:variadic false, :max-fixed-arity 22, :method-params ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :arglists-meta (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)}}, :protocol cljs.core/IFn, :name cljs.core/-invoke, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 22, :method-params ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :arglists-meta (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)}, :method-params ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil), :column 1, :line 525, :end-line 529, :max-fixed-arity 22, :fn-var true, :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :doc nil}, coll? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2085, :column 16, :end-line 2085, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x satisfies ICollection"}, :name cljs.core/coll?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2085, :ret-tag boolean, :end-line 2085, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x satisfies ICollection"}, get-in {:protocol-inline nil, :meta {:added "1.2", :file "cljs/core.cljs", :end-column 13, :static true, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([m ks] [m ks not-found]), :arglists ([m ks] [m ks not-found]), :arglists-meta (nil nil)}, :column 7, :line 4967, :end-line 4967, :arglists (quote ([m ks] [m ks not-found])), :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied."}, :added "1.2", :name cljs.core/get-in, :variadic false, :file "cljs/core.cljs", :end-column 13, :static true, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([m ks] [m ks not-found]), :arglists ([m ks] [m ks not-found]), :arglists-meta (nil nil)}, :method-params ([m ks] [m ks not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4967, :end-line 4967, :max-fixed-arity 3, :fn-var true, :arglists ([m ks] [m ks not-found]), :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied."}, fnext {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1739, :column 7, :end-line 1739, :end-column 12, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, :name cljs.core/fnext, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1739, :end-line 1739, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, IList {:meta {:file "cljs/core.cljs", :line 710, :column 14, :end-line 710, :end-column 19, :doc "Marker interface indicating a persistent list", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/IList, :file "cljs/core.cljs", :end-column 19, :column 1, :line 710, :protocol-info {:methods {}}, :info nil, :end-line 710, :tag any, :impls #{cljs.core/Cons cljs.core/EmptyList cljs.core/List}, :doc "Marker interface indicating a persistent list", :jsdoc ("@interface")}, ArrayNodeIterator {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/ArrayNodeIterator, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7091, :record false, :end-line 7091, :skip-protocol-flag nil}, List {:meta {:file "cljs/core.cljs", :line 1503, :column 45, :end-line 1503, :end-column 49, :declared true}, :num-fields 5, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/List, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 3004, :record false, :declared true, :end-line 3004, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -val {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 636, :column 4, :end-line 636, :end-column 8, :protocol cljs.core/IMapEntry, :doc "Returns the value of the map entry.", :arglists (quote ([coll]))}, :protocol cljs.core/IMapEntry, :name cljs.core/-val, :variadic false, :file "cljs/core.cljs", :end-column 8, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 632, :end-line 636, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the value of the map entry."}, bytes {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2785, :column 7, :end-line 2785, :end-column 12, :arglists (quote ([x]))}, :name cljs.core/bytes, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2785, :end-line 2785, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, ->ObjMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6072, :column 10, :end-line 6072, :end-column 16, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :factory :positional, :arglists (quote ([meta keys strobj update-count __hash]))}, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IFind cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->ObjMap, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([meta keys strobj update-count __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6072, :end-line 6072, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta keys strobj update-count __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, compare-symbols {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1034, :column 8, :end-line 1034, :end-column 23, :private true, :arglists (quote ([a b]))}, :private true, :name cljs.core/compare-symbols, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1034, :end-line 1034, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, -seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 704, :column 16, :end-line 704, :end-column 20, :tag clj-or-nil, :protocol cljs.core/ISeqable, :doc "Returns a seq of o, or nil if o is empty.", :arglists (quote ([o]))}, :protocol cljs.core/ISeqable, :name cljs.core/-seq, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 702, :ret-tag clj-or-nil, :end-line 704, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([o])), :doc "Returns a seq of o, or nil if o is empty."}}, :cljs.spec/registry-ref [], :require-macros nil, :cljs.analyzer/constants {:seen #{form tag & uuid meta10465 end defrecord* base obj fqn first try has-nil? rear hierarchy iter step boolean update-count method-table chunk i rest :meta :dup comp dispatch-fn buffer :else left ns* :cljs.core/none shift iters xform :validator finally :default prefer-table loop* watches :ns bitmap _seq nil-val v riter __hash meta _meta afn tree fn front buf next-entry :val key _next root-iter do vec :fallback-impl :flush-on-newline default-dispatch-val :no-test validator letfn* if arr new :descendants ns completed :ancestors value name :readably :more-marker fields method-cache edit editable? base-count collision-hash deftype* let* start sourceIter coll not-native js* strobj _rest fn* val ascending? recur xf ci :print-length state :ok vals :cljs.core/halt cached-hierarchy s :parents cnt node sym sb _hash keys set! :tag tree-map . var :mutable quote root multi str nodes seen hash-map catch :alt-impl ext-map-iter tail record mseq count meta8964 :keywordize-keys off stack transient-map len right throw meta14408 fseq :cljs.core/not-found more def f next-iter}, :order [:flush-on-newline :readably :meta :dup :print-length :else sb :default ns name str _hash :mutable _meta val sym s value iter _rest arr i meta ci afn first rest count __hash fqn fn buf end off chunk more meta8964 _seq _next vals iters buffer completed xf sourceIter multi state validator watches :validator edit base v start cnt shift root tail vec node fseq riter front rear keys strobj update-count record base-count fields ext-map-iter key editable? len next-entry next-iter bitmap collision-hash nodes nil-val root-iter seen has-nil? :tag boolean stack ascending? left right comp tree mseq not-native :cljs.core/not-found hash-map transient-map tree-map step :cljs.core/none :more-marker :alt-impl :fallback-impl :val f :cljs.core/halt xform coll :keywordize-keys :parents :descendants :ancestors dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy uuid & defrecord* try ns* finally loop* do letfn* if new deftype* let* js* fn* recur set! . var quote catch throw def :ok :no-test tag form :ns obj meta10465 meta14408]}, :doc nil}